/* tslint:disable */
/* eslint-disable */
/**
 * OpenWiFi User Portal
 * API describing User Self Care interaction with OpenWifi.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AccessPoint
 */
export interface AccessPoint {
  /**
   *
   * @type {string}
   * @memberof AccessPoint
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AccessPoint
   */
  macAddress?: string;
  /**
   *
   * @type {string}
   * @memberof AccessPoint
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof AccessPoint
   */
  deviceType?: string;
  /**
   *
   * @type {SubscriberDeviceList}
   * @memberof AccessPoint
   */
  subscriberDevices?: SubscriberDeviceList;
  /**
   *
   * @type {IPReservationList}
   * @memberof AccessPoint
   */
  ipReservations?: IPReservationList;
  /**
   *
   * @type {Location}
   * @memberof AccessPoint
   */
  address?: Location;
  /**
   *
   * @type {WifiNetworkList}
   * @memberof AccessPoint
   */
  wifiNetworks?: WifiNetworkList;
  /**
   *
   * @type {InternetConnection}
   * @memberof AccessPoint
   */
  internetConnection?: InternetConnection;
  /**
   *
   * @type {HomeDeviceMode}
   * @memberof AccessPoint
   */
  deviceMode?: HomeDeviceMode;
  /**
   *
   * @type {DnsConfiguration}
   * @memberof AccessPoint
   */
  dnsConfiguration?: DnsConfiguration;
  /**
   *
   * @type {Array<RadioInformation>}
   * @memberof AccessPoint
   */
  radios?: Array<RadioInformation>;
  /**
   *
   * @type {boolean}
   * @memberof AccessPoint
   */
  automaticUpgrade?: boolean;
}
/**
 *
 * @export
 * @interface AccessPointList
 */
export interface AccessPointList {
  /**
   *
   * @type {Array<AccessPoint>}
   * @memberof AccessPointList
   */
  list?: Array<AccessPoint>;
}
/**
 *
 * @export
 * @interface AccessTime
 */
export interface AccessTime {
  /**
   *
   * @type {string}
   * @memberof AccessTime
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof AccessTime
   */
  day?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof AccessTime
   */
  rangeList?: Array<string>;
}
/**
 *
 * @export
 * @interface AccessTimes
 */
export interface AccessTimes {
  /**
   *
   * @type {string}
   * @memberof AccessTimes
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof AccessTimes
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof AccessTimes
   */
  modified?: number;
  /**
   *
   * @type {Array<AccessTime>}
   * @memberof AccessTimes
   */
  schedule?: Array<AccessTime>;
}
/**
 *
 * @export
 * @interface AclTemplate
 */
export interface AclTemplate {
  /**
   *
   * @type {boolean}
   * @memberof AclTemplate
   */
  Read?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AclTemplate
   */
  ReadWrite?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AclTemplate
   */
  ReadWriteCreate?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AclTemplate
   */
  Delete?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AclTemplate
   */
  PortalLogin?: boolean;
}
/**
 *
 * @export
 * @interface Association
 */
export interface Association {
  /**
   *
   * @type {string}
   * @memberof Association
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Association
   */
  ssid?: string;
  /**
   *
   * @type {string}
   * @memberof Association
   */
  macAddress?: string;
  /**
   *
   * @type {number}
   * @memberof Association
   */
  rssi?: number;
  /**
   *
   * @type {number}
   * @memberof Association
   */
  power?: number;
  /**
   *
   * @type {string}
   * @memberof Association
   */
  ipv4?: string;
  /**
   *
   * @type {number}
   * @memberof Association
   */
  ipv6?: number;
  /**
   *
   * @type {number}
   * @memberof Association
   */
  tx?: number;
  /**
   *
   * @type {number}
   * @memberof Association
   */
  rx?: number;
}
/**
 *
 * @export
 * @interface AssociationList
 */
export interface AssociationList {
  /**
   *
   * @type {number}
   * @memberof AssociationList
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof AssociationList
   */
  modified?: number;
  /**
   *
   * @type {Array<Association>}
   * @memberof AssociationList
   */
  associations?: Array<Association>;
}
/**
 *
 * @export
 * @interface Client
 */
export interface Client {
  /**
   *
   * @type {string}
   * @memberof Client
   */
  macAddress?: string;
  /**
   *
   * @type {string}
   * @memberof Client
   */
  speed?: string;
  /**
   *
   * @type {string}
   * @memberof Client
   */
  mode?: string;
  /**
   *
   * @type {string}
   * @memberof Client
   */
  ipv4?: string;
  /**
   *
   * @type {number}
   * @memberof Client
   */
  ipv6?: number;
  /**
   *
   * @type {number}
   * @memberof Client
   */
  tx?: number;
  /**
   *
   * @type {number}
   * @memberof Client
   */
  rx?: number;
}
/**
 *
 * @export
 * @interface ClientList
 */
export interface ClientList {
  /**
   *
   * @type {number}
   * @memberof ClientList
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof ClientList
   */
  modified?: number;
  /**
   *
   * @type {Array<Client>}
   * @memberof ClientList
   */
  clients?: Array<Client>;
}
/**
 *
 * @export
 * @interface DnsConfiguration
 */
export interface DnsConfiguration {
  /**
   *
   * @type {boolean}
   * @memberof DnsConfiguration
   */
  ISP?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof DnsConfiguration
   */
  custom?: boolean;
  /**
   *
   * @type {string}
   * @memberof DnsConfiguration
   */
  primary?: string;
  /**
   *
   * @type {string}
   * @memberof DnsConfiguration
   */
  secondary?: string;
  /**
   *
   * @type {string}
   * @memberof DnsConfiguration
   */
  primaryV6?: string;
  /**
   *
   * @type {string}
   * @memberof DnsConfiguration
   */
  secondaryV6?: string;
}
/**
 *
 * @export
 * @interface HomeDeviceMode
 */
export interface HomeDeviceMode {
  /**
   *
   * @type {string}
   * @memberof HomeDeviceMode
   */
  type?: HomeDeviceModeTypeEnum;
  /**
   *
   * @type {boolean}
   * @memberof HomeDeviceMode
   */
  ipV6Support?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof HomeDeviceMode
   */
  enableLEDS?: boolean;
  /**
   *
   * @type {string}
   * @memberof HomeDeviceMode
   */
  subnet?: string;
  /**
   *
   * @type {number}
   * @memberof HomeDeviceMode
   */
  subnetMask?: number;
  /**
   *
   * @type {string}
   * @memberof HomeDeviceMode
   */
  startIP?: string;
  /**
   *
   * @type {string}
   * @memberof HomeDeviceMode
   */
  endIP?: string;
  /**
   *
   * @type {string}
   * @memberof HomeDeviceMode
   */
  subnetV6?: string;
  /**
   *
   * @type {number}
   * @memberof HomeDeviceMode
   */
  subnetMaskV6?: number;
  /**
   *
   * @type {string}
   * @memberof HomeDeviceMode
   */
  startIPV6?: string;
  /**
   *
   * @type {string}
   * @memberof HomeDeviceMode
   */
  endIPV6?: string;
  /**
   *
   * @type {number}
   * @memberof HomeDeviceMode
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof HomeDeviceMode
   */
  modified?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum HomeDeviceModeTypeEnum {
  Bridge = 'bridge',
  Manual = 'manual',
  Nat = 'nat',
}

/**
 *
 * @export
 * @interface IPReservation
 */
export interface IPReservation {
  /**
   *
   * @type {string}
   * @memberof IPReservation
   */
  nickname?: string;
  /**
   *
   * @type {string}
   * @memberof IPReservation
   */
  ipAddress?: string;
  /**
   *
   * @type {string}
   * @memberof IPReservation
   */
  macAddress?: string;
}
/**
 *
 * @export
 * @interface IPReservationList
 */
export interface IPReservationList {
  /**
   *
   * @type {number}
   * @memberof IPReservationList
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof IPReservationList
   */
  modified?: number;
  /**
   *
   * @type {Array<IPReservation>}
   * @memberof IPReservationList
   */
  reservations?: Array<IPReservation>;
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  mac?: string;
  /**
   *
   * @type {number}
   * @memberof InlineObject
   */
  when?: number;
  /**
   *
   * @type {number}
   * @memberof InlineObject
   */
  duration?: number;
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  pattern?: InlineObjectPatternEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum InlineObjectPatternEnum {
  True = 'true',
  False = 'false',
  Blink = 'blink',
}

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse200
   */
  errorCode?: InlineResponse200ErrorCodeEnum;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  errorText?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  details?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum InlineResponse200ErrorCodeEnum {
  NUMBER_0 = 0,
  NUMBER_1 = 1,
  NUMBER_2 = 2,
  NUMBER_3 = 3,
  NUMBER_4 = 4,
}

/**
 *
 * @export
 * @interface InternetConnection
 */
export interface InternetConnection {
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  type?: InternetConnectionTypeEnum;
  /**
   *
   * @type {boolean}
   * @memberof InternetConnection
   */
  ipV6Support?: boolean;
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  ipAddress?: string;
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  subnetMask?: string;
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  defaultGateway?: string;
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  primaryDns?: string;
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  secondaryDns?: string;
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  ipAddressV6?: string;
  /**
   *
   * @type {number}
   * @memberof InternetConnection
   */
  subnetMaskV6?: number;
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  defaultGatewayV6?: string;
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  primaryDnsV6?: string;
  /**
   *
   * @type {string}
   * @memberof InternetConnection
   */
  secondaryDnsV6?: string;
  /**
   *
   * @type {number}
   * @memberof InternetConnection
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof InternetConnection
   */
  modified?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum InternetConnectionTypeEnum {
  Manual = 'manual',
  Pppoe = 'pppoe',
  Automatic = 'automatic',
}

/**
 *
 * @export
 * @interface Location
 */
export interface Location {
  /**
   *
   * @type {string}
   * @memberof Location
   */
  buildingName?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Location
   */
  addressLines?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  postal?: string;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  country?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Location
   */
  phones?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Location
   */
  mobiles?: Array<string>;
}
/**
 *
 * @export
 * @interface MFAChallengeRequest
 */
export interface MFAChallengeRequest {
  /**
   *
   * @type {string}
   * @memberof MFAChallengeRequest
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof MFAChallengeRequest
   */
  question?: string;
  /**
   *
   * @type {number}
   * @memberof MFAChallengeRequest
   */
  created?: number;
  /**
   *
   * @type {string}
   * @memberof MFAChallengeRequest
   */
  method?: string;
}
/**
 *
 * @export
 * @interface MFAChallengeResponse
 */
export interface MFAChallengeResponse {
  /**
   *
   * @type {string}
   * @memberof MFAChallengeResponse
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof MFAChallengeResponse
   */
  answer?: string;
}
/**
 *
 * @export
 * @interface PasswordChange
 */
export interface PasswordChange {
  /**
   *
   * @type {string}
   * @memberof PasswordChange
   */
  oldPassword?: string;
  /**
   *
   * @type {string}
   * @memberof PasswordChange
   */
  newPassword?: string;
}
/**
 *
 * @export
 * @interface PasswordCreation
 */
export interface PasswordCreation {
  /**
   *
   * @type {string}
   * @memberof PasswordCreation
   */
  newPassword?: string;
}
/**
 *
 * @export
 * @interface RadioHE
 */
export interface RadioHE {
  /**
   *
   * @type {boolean}
   * @memberof RadioHE
   */
  multipleBSSID?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof RadioHE
   */
  ema?: boolean;
  /**
   *
   * @type {number}
   * @memberof RadioHE
   */
  bssColor?: number;
}
/**
 *
 * @export
 * @interface RadioInformation
 */
export interface RadioInformation {
  /**
   *
   * @type {string}
   * @memberof RadioInformation
   */
  band?: RadioInformationBandEnum;
  /**
   *
   * @type {number}
   * @memberof RadioInformation
   */
  bandwidth?: RadioInformationBandwidthEnum;
  /**
   *
   * @type {number | string}
   * @memberof RadioInformation
   */
  channel?: number | string;
  /**
   *
   * @type {string}
   * @memberof RadioInformation
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof RadioInformation
   */
  channelMode?: RadioInformationChannelModeEnum;
  /**
   *
   * @type {number}
   * @memberof RadioInformation
   */
  channelWidth?: RadioInformationChannelWidthEnum;
  /**
   *
   * @type {string}
   * @memberof RadioInformation
   */
  requireMode?: RadioInformationRequireModeEnum;
  /**
   *
   * @type {number}
   * @memberof RadioInformation
   */
  txPower?: number;
  /**
   *
   * @type {boolean}
   * @memberof RadioInformation
   */
  legacyRates?: boolean;
  /**
   *
   * @type {number}
   * @memberof RadioInformation
   */
  beaconInterval?: number;
  /**
   *
   * @type {number}
   * @memberof RadioInformation
   */
  dtimPeriod?: number;
  /**
   *
   * @type {RadioRates}
   * @memberof RadioInformation
   */
  rates?: RadioRates;
  /**
   *
   * @type {RadioHE}
   * @memberof RadioInformation
   */
  he?: RadioHE;
  /**
   *
   * @type {Array<string>}
   * @memberof RadioInformation
   */
  rawInfo?: Array<string>;
}

/**
 * @export
 * @enum {string}
 */
export enum RadioInformationBandEnum {
  _2G = '2G',
  _5G = '5G',
  _5Gl = '5GL',
  _5Gu = '5GU',
  _6G = '6G',
}
/**
 * @export
 * @enum {string}
 */
export enum RadioInformationBandwidthEnum {
  NUMBER_5 = 5,
  NUMBER_10 = 10,
  NUMBER_20 = 20,
}
/**
 * @export
 * @enum {string}
 */
export enum RadioInformationChannelModeEnum {
  Ht = 'HT',
  Vht = 'VHT',
  He = 'HE',
}
/**
 * @export
 * @enum {string}
 */
export enum RadioInformationChannelWidthEnum {
  NUMBER_20 = 20,
  NUMBER_40 = 40,
  NUMBER_80 = 80,
  NUMBER_160 = 160,
  NUMBER_8080 = 8080,
}
/**
 * @export
 * @enum {string}
 */
export enum RadioInformationRequireModeEnum {
  Ht = 'HT',
  Vht = 'VHT',
  He = 'HE',
}

/**
 *
 * @export
 * @interface RadioRates
 */
export interface RadioRates {
  /**
   *
   * @type {number}
   * @memberof RadioRates
   */
  beacon?: RadioRatesBeaconEnum;
  /**
   *
   * @type {number}
   * @memberof RadioRates
   */
  multicast?: RadioRatesMulticastEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum RadioRatesBeaconEnum {
  NUMBER_0 = 0,
  NUMBER_1000 = 1000,
  NUMBER_2000 = 2000,
  NUMBER_5500 = 5500,
  NUMBER_6000 = 6000,
  NUMBER_9000 = 9000,
  NUMBER_11000 = 11000,
  NUMBER_12000 = 12000,
  NUMBER_18000 = 18000,
  NUMBER_24000 = 24000,
  NUMBER_36000 = 36000,
  NUMBER_48000 = 48000,
  NUMBER_54000 = 54000,
}
/**
 * @export
 * @enum {string}
 */
export enum RadioRatesMulticastEnum {
  NUMBER_0 = 0,
  NUMBER_1000 = 1000,
  NUMBER_2000 = 2000,
  NUMBER_5500 = 5500,
  NUMBER_6000 = 6000,
  NUMBER_9000 = 9000,
  NUMBER_11000 = 11000,
  NUMBER_12000 = 12000,
  NUMBER_18000 = 18000,
  NUMBER_24000 = 24000,
  NUMBER_36000 = 36000,
  NUMBER_48000 = 48000,
  NUMBER_54000 = 54000,
}

/**
 *
 * @export
 * @interface SubMfaConfig
 */
export interface SubMfaConfig {
  /**
   *
   * @type {string}
   * @memberof SubMfaConfig
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof SubMfaConfig
   */
  type?: SubMfaConfigTypeEnum;
  /**
   *
   * @type {string}
   * @memberof SubMfaConfig
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof SubMfaConfig
   */
  sms?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum SubMfaConfigTypeEnum {
  Disabled = 'disabled',
  Sms = 'sms',
  Email = 'email',
}

/**
 *
 * @export
 * @interface SubscriberDevice
 */
export interface SubscriberDevice {
  /**
   *
   * @type {string}
   * @memberof SubscriberDevice
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriberDevice
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriberDevice
   */
  macAddress?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriberDevice
   */
  manufacturer?: string;
  /**
   *
   * @type {number}
   * @memberof SubscriberDevice
   */
  firstContact?: number;
  /**
   *
   * @type {number}
   * @memberof SubscriberDevice
   */
  lastContact?: number;
  /**
   *
   * @type {string}
   * @memberof SubscriberDevice
   */
  group?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriberDevice
   */
  icon?: string;
  /**
   *
   * @type {boolean}
   * @memberof SubscriberDevice
   */
  suspended?: boolean;
  /**
   *
   * @type {string}
   * @memberof SubscriberDevice
   */
  ip?: string;
  /**
   *
   * @type {number}
   * @memberof SubscriberDevice
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof SubscriberDevice
   */
  modified?: number;
  /**
   *
   * @type {AccessTimes}
   * @memberof SubscriberDevice
   */
  schedule?: AccessTimes;
}
/**
 *
 * @export
 * @interface SubscriberDeviceList
 */
export interface SubscriberDeviceList {
  /**
   *
   * @type {number}
   * @memberof SubscriberDeviceList
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof SubscriberDeviceList
   */
  modified?: number;
  /**
   *
   * @type {Array<SubscriberDevice>}
   * @memberof SubscriberDeviceList
   */
  devices?: Array<SubscriberDevice>;
}
/**
 *
 * @export
 * @interface SubscriberInfo
 */
export interface SubscriberInfo {
  /**
   *
   * @type {string}
   * @memberof SubscriberInfo
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriberInfo
   */
  userId?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriberInfo
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriberInfo
   */
  initials?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriberInfo
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriberInfo
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriberInfo
   */
  secondaryEmail?: string;
  /**
   *
   * @type {AccessPointList}
   * @memberof SubscriberInfo
   */
  accessPoints?: AccessPointList;
  /**
   *
   * @type {Location}
   * @memberof SubscriberInfo
   */
  serviceAddress?: Location;
  /**
   *
   * @type {Location}
   * @memberof SubscriberInfo
   */
  billingAddress?: Location;
  /**
   *
   * @type {number}
   * @memberof SubscriberInfo
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof SubscriberInfo
   */
  modified?: number;
}
/**
 *
 * @export
 * @interface WebTokenAclTemplate
 */
export interface WebTokenAclTemplate {
  /**
   *
   * @type {AclTemplate}
   * @memberof WebTokenAclTemplate
   */
  aclTemplate?: AclTemplate;
}
/**
 * User Id and password.
 * @export
 * @interface WebTokenRequest
 */
export interface WebTokenRequest {
  /**
   *
   * @type {string}
   * @memberof WebTokenRequest
   */
  userId: string;
  /**
   *
   * @type {string}
   * @memberof WebTokenRequest
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof WebTokenRequest
   */
  newPassword?: string;
  /**
   *
   * @type {string}
   * @memberof WebTokenRequest
   */
  refreshToken?: string;
}
/**
 * Login and Refresh Tokens to be used in subsequent API calls.
 * @export
 * @interface WebTokenResult
 */
export interface WebTokenResult {
  /**
   *
   * @type {string}
   * @memberof WebTokenResult
   */
  access_token?: string;
  /**
   *
   * @type {string}
   * @memberof WebTokenResult
   */
  refresh_token?: string;
  /**
   *
   * @type {string}
   * @memberof WebTokenResult
   */
  token_type?: string;
  /**
   *
   * @type {number}
   * @memberof WebTokenResult
   */
  expires_in?: number;
  /**
   *
   * @type {number}
   * @memberof WebTokenResult
   */
  idle_timeout?: number;
  /**
   *
   * @type {string}
   * @memberof WebTokenResult
   */
  username?: string;
  /**
   *
   * @type {number}
   * @memberof WebTokenResult
   */
  created?: number;
  /**
   *
   * @type {boolean}
   * @memberof WebTokenResult
   */
  userMustChangePassword?: boolean;
  /**
   *
   * @type {number}
   * @memberof WebTokenResult
   */
  errorCode?: number;
  /**
   *
   * @type {WebTokenAclTemplate}
   * @memberof WebTokenResult
   */
  aclTemplate?: WebTokenAclTemplate;
}
/**
 *
 * @export
 * @interface WifiNetwork
 */
export interface WifiNetwork {
  /**
   *
   * @type {string}
   * @memberof WifiNetwork
   */
  type?: WifiNetworkTypeEnum;
  /**
   *
   * @type {string}
   * @memberof WifiNetwork
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof WifiNetwork
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof WifiNetwork
   */
  encryption?: WifiNetworkEncryptionEnum;
  /**
   *
   * @type {Array<string>}
   * @memberof WifiNetwork
   */
  bands?: Array<WifiNetworkBandsEnum>;
}

/**
 * @export
 * @enum {string}
 */
export enum WifiNetworkTypeEnum {
  Main = 'main',
  Guest = 'guest',
}
/**
 * @export
 * @enum {string}
 */
export enum WifiNetworkEncryptionEnum {
  None = 'none',
  Psk = 'psk',
  Psk2 = 'psk2',
  PskMixed = 'psk-mixed',
  Wpa = 'wpa',
  Wpa2 = 'wpa2',
  WpaMixed = 'wpa-mixed',
  Sae = 'sae',
  SaeMixed = 'sae-mixed',
  Wpa3 = 'wpa3',
  Wpa3192 = 'wpa3-192',
  Wpa3Mixed = 'wpa3-mixed',
}
/**
 * @export
 * @enum {string}
 */
export enum WifiNetworkBandsEnum {
  All = 'all',
  _2G = '2G',
  _5G = '5G',
  _5Gl = '5GL',
  _5Gu = '5GU',
  _6G = '6G',
}

/**
 *
 * @export
 * @interface WifiNetworkList
 */
export interface WifiNetworkList {
  /**
   *
   * @type {number}
   * @memberof WifiNetworkList
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof WifiNetworkList
   */
  modified?: number;
  /**
   *
   * @type {Array<WifiNetwork>}
   * @memberof WifiNetworkList
   */
  networks?: Array<WifiNetwork>;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get access token - to be used as Bearer token header for all other API requests.
     * @param {WebTokenRequest | MFAChallengeResponse} webTokenRequestMFAChallengeResponse User id and password
     * @param {string} [newPassword] used when a user is trying to change her password. This will be the new password.
     * @param {boolean} [forgotPassword] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
     * @param {boolean} [requirements] A user forgot her password. This will provided the password requirements.
     * @param {boolean} [resendMFACode]
     * @param {boolean} [completeMFAChallenge]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccessToken: async (
      webTokenRequestMFAChallengeResponse: WebTokenRequest | MFAChallengeResponse,
      newPassword?: string,
      forgotPassword?: boolean,
      requirements?: boolean,
      resendMFACode?: boolean,
      completeMFAChallenge?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webTokenRequestMFAChallengeResponse' is not null or undefined
      assertParamExists('getAccessToken', 'webTokenRequestMFAChallengeResponse', webTokenRequestMFAChallengeResponse);
      const localVarPath = `/oauth2`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (newPassword !== undefined) {
        localVarQueryParameter['newPassword'] = newPassword;
      }

      if (forgotPassword !== undefined) {
        localVarQueryParameter['forgotPassword'] = forgotPassword;
      }

      if (requirements !== undefined) {
        localVarQueryParameter['requirements'] = requirements;
      }

      if (resendMFACode !== undefined) {
        localVarQueryParameter['resendMFACode'] = resendMFACode;
      }

      if (completeMFAChallenge !== undefined) {
        localVarQueryParameter['completeMFAChallenge'] = completeMFAChallenge;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        webTokenRequestMFAChallengeResponse,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Revoke a token.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeAccessToken: async (token: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('removeAccessToken', 'token', token);
      const localVarPath = `/oauth2/{token}`.replace(`{${'token'}}`, encodeURIComponent(String(token)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get access token - to be used as Bearer token header for all other API requests.
     * @param {WebTokenRequest | MFAChallengeResponse} webTokenRequestMFAChallengeResponse User id and password
     * @param {string} [newPassword] used when a user is trying to change her password. This will be the new password.
     * @param {boolean} [forgotPassword] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
     * @param {boolean} [requirements] A user forgot her password. This will provided the password requirements.
     * @param {boolean} [resendMFACode]
     * @param {boolean} [completeMFAChallenge]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccessToken(
      webTokenRequestMFAChallengeResponse: WebTokenRequest | MFAChallengeResponse,
      newPassword?: string,
      forgotPassword?: boolean,
      requirements?: boolean,
      resendMFACode?: boolean,
      completeMFAChallenge?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebTokenResult | MFAChallengeRequest>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessToken(
        webTokenRequestMFAChallengeResponse,
        newPassword,
        forgotPassword,
        requirements,
        resendMFACode,
        completeMFAChallenge,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Revoke a token.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeAccessToken(
      token: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeAccessToken(token, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthenticationApiFp(configuration);
  return {
    /**
     *
     * @summary Get access token - to be used as Bearer token header for all other API requests.
     * @param {WebTokenRequest | MFAChallengeResponse} webTokenRequestMFAChallengeResponse User id and password
     * @param {string} [newPassword] used when a user is trying to change her password. This will be the new password.
     * @param {boolean} [forgotPassword] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
     * @param {boolean} [requirements] A user forgot her password. This will provided the password requirements.
     * @param {boolean} [resendMFACode]
     * @param {boolean} [completeMFAChallenge]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccessToken(
      webTokenRequestMFAChallengeResponse: WebTokenRequest | MFAChallengeResponse,
      newPassword?: string,
      forgotPassword?: boolean,
      requirements?: boolean,
      resendMFACode?: boolean,
      completeMFAChallenge?: boolean,
      options?: any,
    ): AxiosPromise<WebTokenResult | MFAChallengeRequest> {
      return localVarFp
        .getAccessToken(
          webTokenRequestMFAChallengeResponse,
          newPassword,
          forgotPassword,
          requirements,
          resendMFACode,
          completeMFAChallenge,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Revoke a token.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeAccessToken(token: string, options?: any): AxiosPromise<Success> {
      return localVarFp.removeAccessToken(token, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
  /**
   *
   * @summary Get access token - to be used as Bearer token header for all other API requests.
   * @param {WebTokenRequest | MFAChallengeResponse} webTokenRequestMFAChallengeResponse User id and password
   * @param {string} [newPassword] used when a user is trying to change her password. This will be the new password.
   * @param {boolean} [forgotPassword] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
   * @param {boolean} [requirements] A user forgot her password. This will provided the password requirements.
   * @param {boolean} [resendMFACode]
   * @param {boolean} [completeMFAChallenge]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public getAccessToken(
    webTokenRequestMFAChallengeResponse: WebTokenRequest | MFAChallengeResponse,
    newPassword?: string,
    forgotPassword?: boolean,
    requirements?: boolean,
    resendMFACode?: boolean,
    completeMFAChallenge?: boolean,
    options?: any,
  ) {
    return AuthenticationApiFp(this.configuration)
      .getAccessToken(
        webTokenRequestMFAChallengeResponse,
        newPassword,
        forgotPassword,
        requirements,
        resendMFACode,
        completeMFAChallenge,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Revoke a token.
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public removeAccessToken(token: string, options?: any) {
    return AuthenticationApiFp(this.configuration)
      .removeAccessToken(token, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the list of wired clients
     * @param {string} serialNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWiredClients: async (serialNumber: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'serialNumber' is not null or undefined
      assertParamExists('getWiredClients', 'serialNumber', serialNumber);
      const localVarPath = `/wiredclients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serialNumber !== undefined) {
        localVarQueryParameter['serialNumber'] = serialNumber;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ClientsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get the list of wired clients
     * @param {string} serialNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWiredClients(
      serialNumber: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWiredClients(serialNumber, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ClientsApiFp(configuration);
  return {
    /**
     *
     * @summary Get the list of wired clients
     * @param {string} serialNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWiredClients(serialNumber: string, options?: any): AxiosPromise<ClientList> {
      return localVarFp.getWiredClients(serialNumber, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
  /**
   *
   * @summary Get the list of wired clients
   * @param {string} serialNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public getWiredClients(serialNumber: string, options?: any) {
    return ClientsApiFp(this.configuration)
      .getWiredClients(serialNumber, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DeviceCommandsApi - axios parameter creator
 * @export
 */
export const DeviceCommandsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Sending different commands to a device
     * @param {'reboot' | 'blink' | 'upgrade' | 'factory' | 'refresh'} [action]
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performAnAction: async (
      action?: 'reboot' | 'blink' | 'upgrade' | 'factory' | 'refresh',
      inlineObject?: InlineObject,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/action`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (action !== undefined) {
        localVarQueryParameter['action'] = action;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DeviceCommandsApi - functional programming interface
 * @export
 */
export const DeviceCommandsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DeviceCommandsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Sending different commands to a device
     * @param {'reboot' | 'blink' | 'upgrade' | 'factory' | 'refresh'} [action]
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async performAnAction(
      action?: 'reboot' | 'blink' | 'upgrade' | 'factory' | 'refresh',
      inlineObject?: InlineObject,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.performAnAction(action, inlineObject, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DeviceCommandsApi - factory interface
 * @export
 */
export const DeviceCommandsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DeviceCommandsApiFp(configuration);
  return {
    /**
     *
     * @summary Sending different commands to a device
     * @param {'reboot' | 'blink' | 'upgrade' | 'factory' | 'refresh'} [action]
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performAnAction(
      action?: 'reboot' | 'blink' | 'upgrade' | 'factory' | 'refresh',
      inlineObject?: InlineObject,
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp.performAnAction(action, inlineObject, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * DeviceCommandsApi - object-oriented interface
 * @export
 * @class DeviceCommandsApi
 * @extends {BaseAPI}
 */
export class DeviceCommandsApi extends BaseAPI {
  /**
   *
   * @summary Sending different commands to a device
   * @param {'reboot' | 'blink' | 'upgrade' | 'factory' | 'refresh'} [action]
   * @param {InlineObject} [inlineObject]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DeviceCommandsApi
   */
  public performAnAction(
    action?: 'reboot' | 'blink' | 'upgrade' | 'factory' | 'refresh',
    inlineObject?: InlineObject,
    options?: any,
  ) {
    return DeviceCommandsApiFp(this.configuration)
      .performAnAction(action, inlineObject, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * MFAApi - axios parameter creator
 * @export
 */
export const MFAApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Retrieve the current setting for MFA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMFS: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/submfa`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve the current setting for MFA
     * @param {boolean} [startValidation]
     * @param {boolean} [completeValidation]
     * @param {string} [challengeCode]
     * @param {SubMfaConfig} [subMfaConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyMFS: async (
      startValidation?: boolean,
      completeValidation?: boolean,
      challengeCode?: string,
      subMfaConfig?: SubMfaConfig,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/submfa`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (startValidation !== undefined) {
        localVarQueryParameter['startValidation'] = startValidation;
      }

      if (completeValidation !== undefined) {
        localVarQueryParameter['completeValidation'] = completeValidation;
      }

      if (challengeCode !== undefined) {
        localVarQueryParameter['challengeCode'] = challengeCode;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(subMfaConfig, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MFAApi - functional programming interface
 * @export
 */
export const MFAApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MFAApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Retrieve the current setting for MFA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMFS(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMFS(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve the current setting for MFA
     * @param {boolean} [startValidation]
     * @param {boolean} [completeValidation]
     * @param {string} [challengeCode]
     * @param {SubMfaConfig} [subMfaConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modifyMFS(
      startValidation?: boolean,
      completeValidation?: boolean,
      challengeCode?: string,
      subMfaConfig?: SubMfaConfig,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modifyMFS(
        startValidation,
        completeValidation,
        challengeCode,
        subMfaConfig,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * MFAApi - factory interface
 * @export
 */
export const MFAApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = MFAApiFp(configuration);
  return {
    /**
     *
     * @summary Retrieve the current setting for MFA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMFS(options?: any): AxiosPromise<void> {
      return localVarFp.getMFS(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve the current setting for MFA
     * @param {boolean} [startValidation]
     * @param {boolean} [completeValidation]
     * @param {string} [challengeCode]
     * @param {SubMfaConfig} [subMfaConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyMFS(
      startValidation?: boolean,
      completeValidation?: boolean,
      challengeCode?: string,
      subMfaConfig?: SubMfaConfig,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .modifyMFS(startValidation, completeValidation, challengeCode, subMfaConfig, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * MFAApi - object-oriented interface
 * @export
 * @class MFAApi
 * @extends {BaseAPI}
 */
export class MFAApi extends BaseAPI {
  /**
   *
   * @summary Retrieve the current setting for MFA
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MFAApi
   */
  public getMFS(options?: any) {
    return MFAApiFp(this.configuration)
      .getMFS(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve the current setting for MFA
   * @param {boolean} [startValidation]
   * @param {boolean} [completeValidation]
   * @param {string} [challengeCode]
   * @param {SubMfaConfig} [subMfaConfig]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MFAApi
   */
  public modifyMFS(
    startValidation?: boolean,
    completeValidation?: boolean,
    challengeCode?: string,
    subMfaConfig?: SubMfaConfig,
    options?: any,
  ) {
    return MFAApiFp(this.configuration)
      .modifyMFS(startValidation, completeValidation, challengeCode, subMfaConfig, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SubscriberDeviceApi - axios parameter creator
 * @export
 */
export const SubscriberDeviceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary A subscriber is trying to claim a specific SerialNumber.
     * @param {string} serialNumber
     * @param {string} id Any string or ID will be stored along with teh claim.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deviceClaim: async (serialNumber: string, id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'serialNumber' is not null or undefined
      assertParamExists('deviceClaim', 'serialNumber', serialNumber);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deviceClaim', 'id', id);
      const localVarPath = `/claim`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serialNumber !== undefined) {
        localVarQueryParameter['serialNumber'] = serialNumber;
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SubscriberDeviceApi - functional programming interface
 * @export
 */
export const SubscriberDeviceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SubscriberDeviceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary A subscriber is trying to claim a specific SerialNumber.
     * @param {string} serialNumber
     * @param {string} id Any string or ID will be stored along with teh claim.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deviceClaim(
      serialNumber: string,
      id: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deviceClaim(serialNumber, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SubscriberDeviceApi - factory interface
 * @export
 */
export const SubscriberDeviceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SubscriberDeviceApiFp(configuration);
  return {
    /**
     *
     * @summary A subscriber is trying to claim a specific SerialNumber.
     * @param {string} serialNumber
     * @param {string} id Any string or ID will be stored along with teh claim.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deviceClaim(serialNumber: string, id: string, options?: any): AxiosPromise<InlineResponse200> {
      return localVarFp.deviceClaim(serialNumber, id, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SubscriberDeviceApi - object-oriented interface
 * @export
 * @class SubscriberDeviceApi
 * @extends {BaseAPI}
 */
export class SubscriberDeviceApi extends BaseAPI {
  /**
   *
   * @summary A subscriber is trying to claim a specific SerialNumber.
   * @param {string} serialNumber
   * @param {string} id Any string or ID will be stored along with teh claim.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriberDeviceApi
   */
  public deviceClaim(serialNumber: string, id: string, options?: any) {
    return SubscriberDeviceApiFp(this.configuration)
      .deviceClaim(serialNumber, id, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SubscriberInformationApi - axios parameter creator
 * @export
 */
export const SubscriberInformationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the information about the subscriber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriberInfo: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/subscriber`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Modify the information stored about the subscriber
     * @param {SubscriberInfo} [subscriberInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifySubscriberInfo: async (subscriberInfo?: SubscriberInfo, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/subscriber`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(subscriberInfo, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SubscriberInformationApi - functional programming interface
 * @export
 */
export const SubscriberInformationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SubscriberInformationApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get the information about the subscriber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSubscriberInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriberInfo(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Modify the information stored about the subscriber
     * @param {SubscriberInfo} [subscriberInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modifySubscriberInfo(
      subscriberInfo?: SubscriberInfo,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modifySubscriberInfo(subscriberInfo, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SubscriberInformationApi - factory interface
 * @export
 */
export const SubscriberInformationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SubscriberInformationApiFp(configuration);
  return {
    /**
     *
     * @summary Get the information about the subscriber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriberInfo(options?: any): AxiosPromise<void> {
      return localVarFp.getSubscriberInfo(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Modify the information stored about the subscriber
     * @param {SubscriberInfo} [subscriberInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifySubscriberInfo(subscriberInfo?: SubscriberInfo, options?: any): AxiosPromise<void> {
      return localVarFp.modifySubscriberInfo(subscriberInfo, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SubscriberInformationApi - object-oriented interface
 * @export
 * @class SubscriberInformationApi
 * @extends {BaseAPI}
 */
export class SubscriberInformationApi extends BaseAPI {
  /**
   *
   * @summary Get the information about the subscriber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriberInformationApi
   */
  public getSubscriberInfo(options?: any) {
    return SubscriberInformationApiFp(this.configuration)
      .getSubscriberInfo(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Modify the information stored about the subscriber
   * @param {SubscriberInfo} [subscriberInfo]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriberInformationApi
   */
  public modifySubscriberInfo(subscriberInfo?: SubscriberInfo, options?: any) {
    return SubscriberInformationApiFp(this.configuration)
      .modifySubscriberInfo(subscriberInfo, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * WiFiClientsApi - axios parameter creator
 * @export
 */
export const WiFiClientsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the list of wired clients
     * @param {string} serialNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWifiClients: async (serialNumber: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'serialNumber' is not null or undefined
      assertParamExists('getWifiClients', 'serialNumber', serialNumber);
      const localVarPath = `/wificlients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serialNumber !== undefined) {
        localVarQueryParameter['serialNumber'] = serialNumber;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WiFiClientsApi - functional programming interface
 * @export
 */
export const WiFiClientsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WiFiClientsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get the list of wired clients
     * @param {string} serialNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWifiClients(
      serialNumber: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssociationList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWifiClients(serialNumber, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * WiFiClientsApi - factory interface
 * @export
 */
export const WiFiClientsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WiFiClientsApiFp(configuration);
  return {
    /**
     *
     * @summary Get the list of wired clients
     * @param {string} serialNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWifiClients(serialNumber: string, options?: any): AxiosPromise<AssociationList> {
      return localVarFp.getWifiClients(serialNumber, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * WiFiClientsApi - object-oriented interface
 * @export
 * @class WiFiClientsApi
 * @extends {BaseAPI}
 */
export class WiFiClientsApi extends BaseAPI {
  /**
   *
   * @summary Get the list of wired clients
   * @param {string} serialNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WiFiClientsApi
   */
  public getWifiClients(serialNumber: string, options?: any) {
    return WiFiClientsApiFp(this.configuration)
      .getWifiClients(serialNumber, options)
      .then(request => request(this.axios, this.basePath));
  }
}
