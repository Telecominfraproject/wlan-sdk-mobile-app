/* tslint:disable */
/* eslint-disable */
/**
 * uCentral Security API
 * A process to manage security logins.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: ucentralsupport@arilia.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AclTemplate
 */
export interface AclTemplate {
  /**
   *
   * @type {boolean}
   * @memberof AclTemplate
   */
  Read?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AclTemplate
   */
  ReadWrite?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AclTemplate
   */
  ReadWriteCreate?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AclTemplate
   */
  Delete?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AclTemplate
   */
  PortalLogin?: boolean;
}
/**
 *
 * @export
 * @interface AnyPayload
 */
export interface AnyPayload {
  /**
   *
   * @type {string}
   * @memberof AnyPayload
   */
  Document?: string;
}
/**
 *
 * @export
 * @interface ApiKeyCreationAnswer
 */
export interface ApiKeyCreationAnswer {
  /**
   *
   * @type {string}
   * @memberof ApiKeyCreationAnswer
   */
  UUID?: string;
  /**
   *
   * @type {string}
   * @memberof ApiKeyCreationAnswer
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof ApiKeyCreationAnswer
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof ApiKeyCreationAnswer
   */
  expiresOn?: number;
  /**
   *
   * @type {string}
   * @memberof ApiKeyCreationAnswer
   */
  apiKey?: string;
  /**
   *
   * @type {AclTemplate}
   * @memberof ApiKeyCreationAnswer
   */
  rights?: AclTemplate;
}
/**
 *
 * @export
 * @interface ApiKeyCreationRequest
 */
export interface ApiKeyCreationRequest {
  /**
   *
   * @type {string}
   * @memberof ApiKeyCreationRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ApiKeyCreationRequest
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof ApiKeyCreationRequest
   */
  expiresOn?: number;
  /**
   *
   * @type {AclTemplate}
   * @memberof ApiKeyCreationRequest
   */
  rights?: AclTemplate;
}
/**
 *
 * @export
 * @interface EMailInfo
 */
export interface EMailInfo {
  /**
   *
   * @type {string}
   * @memberof EMailInfo
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof EMailInfo
   */
  subject?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof EMailInfo
   */
  recipients?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof EMailInfo
   */
  text?: string;
}
/**
 *
 * @export
 * @interface InlineResponse500
 */
export interface InlineResponse500 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse500
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InternalServiceInfo
 */
export interface InternalServiceInfo {
  /**
   *
   * @type {string}
   * @memberof InternalServiceInfo
   */
  privateURI?: string;
  /**
   *
   * @type {string}
   * @memberof InternalServiceInfo
   */
  publicURI?: string;
  /**
   *
   * @type {string}
   * @memberof InternalServiceInfo
   */
  token?: string;
}
/**
 *
 * @export
 * @interface InternalSystemServices
 */
export interface InternalSystemServices {
  /**
   *
   * @type {string}
   * @memberof InternalSystemServices
   */
  key?: string;
  /**
   *
   * @type {number}
   * @memberof InternalSystemServices
   */
  version?: number;
  /**
   *
   * @type {Array<InternalServiceInfo>}
   * @memberof InternalSystemServices
   */
  services?: Array<InternalServiceInfo>;
}
/**
 *
 * @export
 * @interface MFAChallengeRequest
 */
export interface MFAChallengeRequest {
  /**
   *
   * @type {string}
   * @memberof MFAChallengeRequest
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof MFAChallengeRequest
   */
  question?: string;
  /**
   *
   * @type {number}
   * @memberof MFAChallengeRequest
   */
  created?: number;
  /**
   *
   * @type {string}
   * @memberof MFAChallengeRequest
   */
  method?: string;
}
/**
 *
 * @export
 * @interface MFAChallengeResponse
 */
export interface MFAChallengeResponse {
  /**
   *
   * @type {string}
   * @memberof MFAChallengeResponse
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof MFAChallengeResponse
   */
  answer?: string;
}
/**
 *
 * @export
 * @interface MfaAuthInfo
 */
export interface MfaAuthInfo {
  /**
   *
   * @type {boolean}
   * @memberof MfaAuthInfo
   */
  enabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof MfaAuthInfo
   */
  method?: MfaAuthInfoMethodEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum MfaAuthInfoMethodEnum {
  Sms = 'sms',
  Email = 'email',
  Voice = 'voice',
}

/**
 *
 * @export
 * @interface MobilePhoneNumber
 */
export interface MobilePhoneNumber {
  /**
   *
   * @type {string}
   * @memberof MobilePhoneNumber
   */
  number?: string;
  /**
   *
   * @type {boolean}
   * @memberof MobilePhoneNumber
   */
  verified?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MobilePhoneNumber
   */
  primary?: boolean;
}
/**
 *
 * @export
 * @interface NoteInfo
 */
export interface NoteInfo {
  /**
   *
   * @type {number}
   * @memberof NoteInfo
   */
  created?: number;
  /**
   *
   * @type {string}
   * @memberof NoteInfo
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof NoteInfo
   */
  note?: string;
}
/**
 *
 * @export
 * @interface ProfileAction
 */
export interface ProfileAction {
  /**
   *
   * @type {string}
   * @memberof ProfileAction
   */
  resource?: string;
  /**
   *
   * @type {string}
   * @memberof ProfileAction
   */
  access?: ProfileActionAccessEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ProfileActionAccessEnum {
  None = 'NONE',
  Read = 'READ',
  Modify = 'MODIFY',
  Delete = 'DELETE',
  Create = 'CREATE',
  Test = 'TEST',
  Move = 'MOVE',
}

/**
 *
 * @export
 * @interface SMSInfo
 */
export interface SMSInfo {
  /**
   *
   * @type {string}
   * @memberof SMSInfo
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof SMSInfo
   */
  to?: string;
  /**
   *
   * @type {string}
   * @memberof SMSInfo
   */
  text?: string;
}
/**
 *
 * @export
 * @interface SecurityProfile
 */
export interface SecurityProfile {
  /**
   *
   * @type {number}
   * @memberof SecurityProfile
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof SecurityProfile
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof SecurityProfile
   */
  description?: string;
  /**
   *
   * @type {Array<ProfileAction>}
   * @memberof SecurityProfile
   */
  policy?: Array<ProfileAction>;
  /**
   *
   * @type {string}
   * @memberof SecurityProfile
   */
  role?: string;
  /**
   *
   * @type {Array<NoteInfo>}
   * @memberof SecurityProfile
   */
  notes?: Array<NoteInfo>;
}
/**
 *
 * @export
 * @interface SecurityProfileList
 */
export interface SecurityProfileList {
  /**
   *
   * @type {Array<SecurityProfile>}
   * @memberof SecurityProfileList
   */
  profiles?: Array<SecurityProfile>;
}
/**
 *
 * @export
 * @interface StringList
 */
export interface StringList {
  /**
   *
   * @type {Array<string>}
   * @memberof StringList
   */
  list?: Array<string>;
}
/**
 *
 * @export
 * @interface SystemCommandDetails
 */
export interface SystemCommandDetails {
  /**
   *
   * @type {string}
   * @memberof SystemCommandDetails
   */
  command?: SystemCommandDetailsCommandEnum;
  /**
   *
   * @type {StringList | TagValuePairList}
   * @memberof SystemCommandDetails
   */
  parameters?: StringList | TagValuePairList;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandDetailsCommandEnum {
  Setloglevels = 'setloglevels',
  Getloglevels = 'getloglevels',
  GetSubSystemNames = 'getSubSystemNames',
  GetLogLevelNames = 'getLogLevelNames',
  Stats = 'stats',
}

/**
 *
 * @export
 * @interface SystemCommandGetLogLevelNames
 */
export interface SystemCommandGetLogLevelNames {
  /**
   *
   * @type {string}
   * @memberof SystemCommandGetLogLevelNames
   */
  command?: SystemCommandGetLogLevelNamesCommandEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandGetLogLevelNamesCommandEnum {
  Getloglevelnames = 'getloglevelnames',
}

/**
 *
 * @export
 * @interface SystemCommandGetLogLevelNamesResult
 */
export interface SystemCommandGetLogLevelNamesResult {
  /**
   *
   * @type {Array<string>}
   * @memberof SystemCommandGetLogLevelNamesResult
   */
  list?: Array<string>;
}
/**
 *
 * @export
 * @interface SystemCommandGetLogLevels
 */
export interface SystemCommandGetLogLevels {
  /**
   *
   * @type {string}
   * @memberof SystemCommandGetLogLevels
   */
  command?: SystemCommandGetLogLevelsCommandEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandGetLogLevelsCommandEnum {
  Getloglevels = 'getloglevels',
}

/**
 *
 * @export
 * @interface SystemCommandGetSubsystemNames
 */
export interface SystemCommandGetSubsystemNames {
  /**
   *
   * @type {string}
   * @memberof SystemCommandGetSubsystemNames
   */
  command?: SystemCommandGetSubsystemNamesCommandEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandGetSubsystemNamesCommandEnum {
  Getsubsystemnames = 'getsubsystemnames',
}

/**
 *
 * @export
 * @interface SystemCommandReload
 */
export interface SystemCommandReload {
  /**
   *
   * @type {string}
   * @memberof SystemCommandReload
   */
  command?: SystemCommandReloadCommandEnum;
  /**
   *
   * @type {Array<string>}
   * @memberof SystemCommandReload
   */
  subsystems?: Array<string>;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandReloadCommandEnum {
  Reload = 'reload',
}

/**
 * @type SystemCommandResults
 * @export
 */
export type SystemCommandResults = StringList | TagValuePairList;

/**
 *
 * @export
 * @interface SystemCommandSetLogLevel
 */
export interface SystemCommandSetLogLevel {
  /**
   *
   * @type {string}
   * @memberof SystemCommandSetLogLevel
   */
  command?: SystemCommandSetLogLevelCommandEnum;
  /**
   *
   * @type {Array<TagValuePair>}
   * @memberof SystemCommandSetLogLevel
   */
  subsystems?: Array<TagValuePair>;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandSetLogLevelCommandEnum {
  Setloglevel = 'setloglevel',
}

/**
 *
 * @export
 * @interface SystemEndpoint
 */
export interface SystemEndpoint {
  /**
   *
   * @type {string}
   * @memberof SystemEndpoint
   */
  type?: string;
  /**
   *
   * @type {number}
   * @memberof SystemEndpoint
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof SystemEndpoint
   */
  vendor?: string;
  /**
   *
   * @type {string}
   * @memberof SystemEndpoint
   */
  uri?: string;
  /**
   *
   * @type {string}
   * @memberof SystemEndpoint
   */
  authenticationType?: string;
}
/**
 *
 * @export
 * @interface SystemEndpointList
 */
export interface SystemEndpointList {
  /**
   *
   * @type {Array<SystemEndpoint>}
   * @memberof SystemEndpointList
   */
  endpoints?: Array<SystemEndpoint>;
}
/**
 *
 * @export
 * @interface SystemGetLogLevelsResult
 */
export interface SystemGetLogLevelsResult {
  /**
   *
   * @type {Array<TagValuePair>}
   * @memberof SystemGetLogLevelsResult
   */
  taglist?: Array<TagValuePair>;
}
/**
 *
 * @export
 * @interface SystemGetSubSystemNemesResult
 */
export interface SystemGetSubSystemNemesResult {
  /**
   *
   * @type {Array<TagValuePair>}
   * @memberof SystemGetSubSystemNemesResult
   */
  taglist?: Array<TagValuePair>;
}
/**
 *
 * @export
 * @interface SystemInfoResults
 */
export interface SystemInfoResults {
  /**
   *
   * @type {string}
   * @memberof SystemInfoResults
   */
  version?: string;
  /**
   *
   * @type {number}
   * @memberof SystemInfoResults
   */
  uptime?: number;
  /**
   *
   * @type {number}
   * @memberof SystemInfoResults
   */
  start?: number;
  /**
   *
   * @type {string}
   * @memberof SystemInfoResults
   */
  os?: string;
  /**
   *
   * @type {number}
   * @memberof SystemInfoResults
   */
  processors?: number;
  /**
   *
   * @type {string}
   * @memberof SystemInfoResults
   */
  hostname?: string;
  /**
   *
   * @type {Array<SystemInfoResultsCertificates>}
   * @memberof SystemInfoResults
   */
  certificates?: Array<SystemInfoResultsCertificates>;
}
/**
 *
 * @export
 * @interface SystemInfoResultsCertificates
 */
export interface SystemInfoResultsCertificates {
  /**
   *
   * @type {string}
   * @memberof SystemInfoResultsCertificates
   */
  filename?: string;
  /**
   *
   * @type {number}
   * @memberof SystemInfoResultsCertificates
   */
  expires?: number;
}
/**
 *
 * @export
 * @interface TagValuePair
 */
export interface TagValuePair {
  /**
   *
   * @type {string}
   * @memberof TagValuePair
   */
  tag?: string;
  /**
   *
   * @type {string}
   * @memberof TagValuePair
   */
  value?: string;
}
/**
 *
 * @export
 * @interface TagValuePairList
 */
export interface TagValuePairList {
  /**
   *
   * @type {Array<TagValuePair>}
   * @memberof TagValuePairList
   */
  tagList?: Array<TagValuePair>;
}
/**
 *
 * @export
 * @interface TokenValidationResult
 */
export interface TokenValidationResult {
  /**
   *
   * @type {UserInfo}
   * @memberof TokenValidationResult
   */
  userInfo?: UserInfo;
  /**
   *
   * @type {WebTokenResult}
   * @memberof TokenValidationResult
   */
  tokenInfo?: WebTokenResult;
}
/**
 *
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  avatar?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  email?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserInfo
   */
  validated?: boolean;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  validationEmail?: string;
  /**
   *
   * @type {number}
   * @memberof UserInfo
   */
  validationDate?: number;
  /**
   *
   * @type {number}
   * @memberof UserInfo
   */
  created?: number;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  validationURI?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserInfo
   */
  changePassword?: boolean;
  /**
   *
   * @type {number}
   * @memberof UserInfo
   */
  lastLogin?: number;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  currentLoginURI?: string;
  /**
   *
   * @type {number}
   * @memberof UserInfo
   */
  lastPasswordChange?: number;
  /**
   *
   * @type {number}
   * @memberof UserInfo
   */
  lastEmailCheck?: number;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  currentPassword?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UserInfo
   */
  lastPasswords?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof UserInfo
   */
  waitingForEmailCheck?: boolean;
  /**
   *
   * @type {Array<NoteInfo>}
   * @memberof UserInfo
   */
  notes?: Array<NoteInfo>;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  location?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  owner?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserInfo
   */
  suspended?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserInfo
   */
  blackListed?: boolean;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  locale?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  userRole?: UserInfoUserRoleEnum;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  oauthType?: UserInfoOauthTypeEnum;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  oauthUserInfo?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  securityPolicy?: string;
  /**
   *
   * @type {number}
   * @memberof UserInfo
   */
  securityPolicyChange?: number;
  /**
   *
   * @type {UserLoginLoginExtensions}
   * @memberof UserInfo
   */
  userTypeProprietaryInfo?: UserLoginLoginExtensions;
}

/**
 * @export
 * @enum {string}
 */
export enum UserInfoUserRoleEnum {
  Root = 'root',
  Admin = 'admin',
  Subscriber = 'subscriber',
  Csr = 'csr',
  System = 'system',
  Installer = 'installer',
  Noc = 'noc',
  Accounting = 'accounting',
}
/**
 * @export
 * @enum {string}
 */
export enum UserInfoOauthTypeEnum {
  Internal = 'internal',
  Normal = 'normal',
  Gmail = 'gmail',
  Facebook = 'facebook',
  Linkedin = 'linkedin',
  Instagram = 'instagram',
}

/**
 *
 * @export
 * @interface UserList
 */
export interface UserList {
  /**
   *
   * @type {Array<UserInfo>}
   * @memberof UserList
   */
  users?: Array<UserInfo>;
}
/**
 *
 * @export
 * @interface UserLoginLoginExtensions
 */
export interface UserLoginLoginExtensions {
  /**
   *
   * @type {Array<MobilePhoneNumber>}
   * @memberof UserLoginLoginExtensions
   */
  mobiles?: Array<MobilePhoneNumber>;
  /**
   *
   * @type {MfaAuthInfo}
   * @memberof UserLoginLoginExtensions
   */
  mfa?: MfaAuthInfo;
}
/**
 *
 * @export
 * @interface WebTokenAclTemplate
 */
export interface WebTokenAclTemplate {
  /**
   *
   * @type {AclTemplate}
   * @memberof WebTokenAclTemplate
   */
  aclTemplate?: AclTemplate;
}
/**
 * User Id and password.
 * @export
 * @interface WebTokenRequest
 */
export interface WebTokenRequest {
  /**
   *
   * @type {string}
   * @memberof WebTokenRequest
   */
  userId: string;
  /**
   *
   * @type {string}
   * @memberof WebTokenRequest
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof WebTokenRequest
   */
  newPassword?: string;
  /**
   *
   * @type {string}
   * @memberof WebTokenRequest
   */
  refreshToken?: string;
}
/**
 * Login and Refresh Tokens to be used in subsequent API calls.
 * @export
 * @interface WebTokenResult
 */
export interface WebTokenResult {
  /**
   *
   * @type {string}
   * @memberof WebTokenResult
   */
  access_token?: string;
  /**
   *
   * @type {string}
   * @memberof WebTokenResult
   */
  refresh_token?: string;
  /**
   *
   * @type {string}
   * @memberof WebTokenResult
   */
  token_type?: string;
  /**
   *
   * @type {number}
   * @memberof WebTokenResult
   */
  expires_in?: number;
  /**
   *
   * @type {number}
   * @memberof WebTokenResult
   */
  idle_timeout?: number;
  /**
   *
   * @type {string}
   * @memberof WebTokenResult
   */
  username?: string;
  /**
   *
   * @type {number}
   * @memberof WebTokenResult
   */
  created?: number;
  /**
   *
   * @type {boolean}
   * @memberof WebTokenResult
   */
  userMustChangePassword?: boolean;
  /**
   *
   * @type {number}
   * @memberof WebTokenResult
   */
  errorCode?: number;
  /**
   *
   * @type {WebTokenAclTemplate}
   * @memberof WebTokenResult
   */
  aclTemplate?: WebTokenAclTemplate;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get access token - to be used as Bearer token header for all other API requests.
     * @param {WebTokenRequest | MFAChallengeResponse} webTokenRequestMFAChallengeResponse User id and password
     * @param {string} [newPassword] used when a user is trying to change her password. This will be the new password.
     * @param {boolean} [forgotPassword] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
     * @param {boolean} [requirements] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
     * @param {boolean} [resendMFACode]
     * @param {boolean} [completeMFAChallenge]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccessToken: async (
      webTokenRequestMFAChallengeResponse: WebTokenRequest | MFAChallengeResponse,
      newPassword?: string,
      forgotPassword?: boolean,
      requirements?: boolean,
      resendMFACode?: boolean,
      completeMFAChallenge?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webTokenRequestMFAChallengeResponse' is not null or undefined
      assertParamExists('getAccessToken', 'webTokenRequestMFAChallengeResponse', webTokenRequestMFAChallengeResponse);
      const localVarPath = `/oauth2`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (newPassword !== undefined) {
        localVarQueryParameter['newPassword'] = newPassword;
      }

      if (forgotPassword !== undefined) {
        localVarQueryParameter['forgotPassword'] = forgotPassword;
      }

      if (requirements !== undefined) {
        localVarQueryParameter['requirements'] = requirements;
      }

      if (resendMFACode !== undefined) {
        localVarQueryParameter['resendMFACode'] = resendMFACode;
      }

      if (completeMFAChallenge !== undefined) {
        localVarQueryParameter['completeMFAChallenge'] = completeMFAChallenge;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        webTokenRequestMFAChallengeResponse,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve the system layout.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemInfo: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/systemEndpoints`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Revoke a token.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeAccessToken: async (token: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('removeAccessToken', 'token', token);
      const localVarPath = `/oauth2/{token}`.replace(`{${'token'}}`, encodeURIComponent(String(token)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get access token - to be used as Bearer token header for all other API requests.
     * @param {WebTokenRequest | MFAChallengeResponse} webTokenRequestMFAChallengeResponse User id and password
     * @param {string} [newPassword] used when a user is trying to change her password. This will be the new password.
     * @param {boolean} [forgotPassword] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
     * @param {boolean} [requirements] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
     * @param {boolean} [resendMFACode]
     * @param {boolean} [completeMFAChallenge]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccessToken(
      webTokenRequestMFAChallengeResponse: WebTokenRequest | MFAChallengeResponse,
      newPassword?: string,
      forgotPassword?: boolean,
      requirements?: boolean,
      resendMFACode?: boolean,
      completeMFAChallenge?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebTokenResult | MFAChallengeRequest>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessToken(
        webTokenRequestMFAChallengeResponse,
        newPassword,
        forgotPassword,
        requirements,
        resendMFACode,
        completeMFAChallenge,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve the system layout.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystemInfo(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemEndpointList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemInfo(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Revoke a token.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeAccessToken(
      token: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeAccessToken(token, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthenticationApiFp(configuration);
  return {
    /**
     *
     * @summary Get access token - to be used as Bearer token header for all other API requests.
     * @param {WebTokenRequest | MFAChallengeResponse} webTokenRequestMFAChallengeResponse User id and password
     * @param {string} [newPassword] used when a user is trying to change her password. This will be the new password.
     * @param {boolean} [forgotPassword] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
     * @param {boolean} [requirements] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
     * @param {boolean} [resendMFACode]
     * @param {boolean} [completeMFAChallenge]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccessToken(
      webTokenRequestMFAChallengeResponse: WebTokenRequest | MFAChallengeResponse,
      newPassword?: string,
      forgotPassword?: boolean,
      requirements?: boolean,
      resendMFACode?: boolean,
      completeMFAChallenge?: boolean,
      options?: any,
    ): AxiosPromise<WebTokenResult | MFAChallengeRequest> {
      return localVarFp
        .getAccessToken(
          webTokenRequestMFAChallengeResponse,
          newPassword,
          forgotPassword,
          requirements,
          resendMFACode,
          completeMFAChallenge,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve the system layout.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemInfo(options?: any): AxiosPromise<SystemEndpointList> {
      return localVarFp.getSystemInfo(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Revoke a token.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeAccessToken(token: string, options?: any): AxiosPromise<Success> {
      return localVarFp.removeAccessToken(token, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
  /**
   *
   * @summary Get access token - to be used as Bearer token header for all other API requests.
   * @param {WebTokenRequest | MFAChallengeResponse} webTokenRequestMFAChallengeResponse User id and password
   * @param {string} [newPassword] used when a user is trying to change her password. This will be the new password.
   * @param {boolean} [forgotPassword] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
   * @param {boolean} [requirements] A user forgot her password. She needs to present her e-mail address in the userId and set this to true
   * @param {boolean} [resendMFACode]
   * @param {boolean} [completeMFAChallenge]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public getAccessToken(
    webTokenRequestMFAChallengeResponse: WebTokenRequest | MFAChallengeResponse,
    newPassword?: string,
    forgotPassword?: boolean,
    requirements?: boolean,
    resendMFACode?: boolean,
    completeMFAChallenge?: boolean,
    options?: any,
  ) {
    return AuthenticationApiFp(this.configuration)
      .getAccessToken(
        webTokenRequestMFAChallengeResponse,
        newPassword,
        forgotPassword,
        requirements,
        resendMFACode,
        completeMFAChallenge,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve the system layout.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public getSystemInfo(options?: any) {
    return AuthenticationApiFp(this.configuration)
      .getSystemInfo(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Revoke a token.
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public removeAccessToken(token: string, options?: any) {
    return AuthenticationApiFp(this.configuration)
      .removeAccessToken(token, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * AvatarApi - axios parameter creator
 * @export
 */
export const AvatarApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create an avatar associated with a user ID.
     * @param {string} id
     * @param {any} body User id and password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAvatar: async (id: string, body: any, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createAvatar', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createAvatar', 'body', body);
      const localVarPath = `/avatar/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'image/jpeg';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove an avatar associated with a user ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAvatar: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteAvatar', 'id', id);
      const localVarPath = `/avatar/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve the avatar associated with a user ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvatar: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getAvatar', 'id', id);
      const localVarPath = `/avatar/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AvatarApi - functional programming interface
 * @export
 */
export const AvatarApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AvatarApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create an avatar associated with a user ID.
     * @param {string} id
     * @param {any} body User id and password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAvatar(
      id: string,
      body: any,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAvatar(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Remove an avatar associated with a user ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAvatar(
      id: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAvatar(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve the avatar associated with a user ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAvatar(
      id: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAvatar(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AvatarApi - factory interface
 * @export
 */
export const AvatarApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AvatarApiFp(configuration);
  return {
    /**
     *
     * @summary Create an avatar associated with a user ID.
     * @param {string} id
     * @param {any} body User id and password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAvatar(id: string, body: any, options?: any): AxiosPromise<object> {
      return localVarFp.createAvatar(id, body, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Remove an avatar associated with a user ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAvatar(id: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteAvatar(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve the avatar associated with a user ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvatar(id: string, options?: any): AxiosPromise<any> {
      return localVarFp.getAvatar(id, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * AvatarApi - object-oriented interface
 * @export
 * @class AvatarApi
 * @extends {BaseAPI}
 */
export class AvatarApi extends BaseAPI {
  /**
   *
   * @summary Create an avatar associated with a user ID.
   * @param {string} id
   * @param {any} body User id and password
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AvatarApi
   */
  public createAvatar(id: string, body: any, options?: any) {
    return AvatarApiFp(this.configuration)
      .createAvatar(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove an avatar associated with a user ID.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AvatarApi
   */
  public deleteAvatar(id: string, options?: any) {
    return AvatarApiFp(this.configuration)
      .deleteAvatar(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve the avatar associated with a user ID.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AvatarApi
   */
  public getAvatar(id: string, options?: any) {
    return AvatarApiFp(this.configuration)
      .getAvatar(id, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * EmailApi - axios parameter creator
 * @export
 */
export const EmailApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Send test email with the system.
     * @param {EMailInfo} [eMailInfo] The requested message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendATestEmail: async (eMailInfo?: EMailInfo, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/email`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(eMailInfo, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send test email with the system.
     * @param {boolean} [validateNumber]
     * @param {boolean} [completeValidation]
     * @param {string} [validationCode]
     * @param {SMSInfo} [sMSInfo] The requested message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendATestSMS: async (
      validateNumber?: boolean,
      completeValidation?: boolean,
      validationCode?: string,
      sMSInfo?: SMSInfo,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/sms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (validateNumber !== undefined) {
        localVarQueryParameter['validateNumber'] = validateNumber;
      }

      if (completeValidation !== undefined) {
        localVarQueryParameter['completeValidation'] = completeValidation;
      }

      if (validationCode !== undefined) {
        localVarQueryParameter['validationCode'] = validationCode;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(sMSInfo, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EmailApi - functional programming interface
 * @export
 */
export const EmailApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EmailApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Send test email with the system.
     * @param {EMailInfo} [eMailInfo] The requested message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendATestEmail(
      eMailInfo?: EMailInfo,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendATestEmail(eMailInfo, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Send test email with the system.
     * @param {boolean} [validateNumber]
     * @param {boolean} [completeValidation]
     * @param {string} [validationCode]
     * @param {SMSInfo} [sMSInfo] The requested message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendATestSMS(
      validateNumber?: boolean,
      completeValidation?: boolean,
      validationCode?: string,
      sMSInfo?: SMSInfo,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendATestSMS(
        validateNumber,
        completeValidation,
        validationCode,
        sMSInfo,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * EmailApi - factory interface
 * @export
 */
export const EmailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EmailApiFp(configuration);
  return {
    /**
     *
     * @summary Send test email with the system.
     * @param {EMailInfo} [eMailInfo] The requested message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendATestEmail(eMailInfo?: EMailInfo, options?: any): AxiosPromise<object> {
      return localVarFp.sendATestEmail(eMailInfo, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Send test email with the system.
     * @param {boolean} [validateNumber]
     * @param {boolean} [completeValidation]
     * @param {string} [validationCode]
     * @param {SMSInfo} [sMSInfo] The requested message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendATestSMS(
      validateNumber?: boolean,
      completeValidation?: boolean,
      validationCode?: string,
      sMSInfo?: SMSInfo,
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .sendATestSMS(validateNumber, completeValidation, validationCode, sMSInfo, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * EmailApi - object-oriented interface
 * @export
 * @class EmailApi
 * @extends {BaseAPI}
 */
export class EmailApi extends BaseAPI {
  /**
   *
   * @summary Send test email with the system.
   * @param {EMailInfo} [eMailInfo] The requested message
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailApi
   */
  public sendATestEmail(eMailInfo?: EMailInfo, options?: any) {
    return EmailApiFp(this.configuration)
      .sendATestEmail(eMailInfo, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Send test email with the system.
   * @param {boolean} [validateNumber]
   * @param {boolean} [completeValidation]
   * @param {string} [validationCode]
   * @param {SMSInfo} [sMSInfo] The requested message
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailApi
   */
  public sendATestSMS(
    validateNumber?: boolean,
    completeValidation?: boolean,
    validationCode?: string,
    sMSInfo?: SMSInfo,
    options?: any,
  ) {
    return EmailApiFp(this.configuration)
      .sendATestSMS(validateNumber, completeValidation, validationCode, sMSInfo, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Retrieve the list of security profiles for a specific service type.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSecurituProfiles: async (
      offset?: number,
      limit?: number,
      filter?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/securityProfiles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve the basic system information. This information is used between services only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemServices: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/systemServices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Allows any microservice to validate a token and get security policy for a specific user.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateToken: async (token: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('validateToken', 'token', token);
      const localVarPath = `/validateToken`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (token !== undefined) {
        localVarQueryParameter['token'] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Retrieve the list of security profiles for a specific service type.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSecurituProfiles(
      offset?: number,
      limit?: number,
      filter?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSecurituProfiles(offset, limit, filter, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve the basic system information. This information is used between services only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystemServices(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemServices(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Allows any microservice to validate a token and get security policy for a specific user.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateToken(
      token: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validateToken(token, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SecurityApiFp(configuration);
  return {
    /**
     *
     * @summary Retrieve the list of security profiles for a specific service type.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSecurituProfiles(offset?: number, limit?: number, filter?: string, options?: any): AxiosPromise<void> {
      return localVarFp.getSecurituProfiles(offset, limit, filter, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve the basic system information. This information is used between services only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemServices(options?: any): AxiosPromise<void> {
      return localVarFp.getSystemServices(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Allows any microservice to validate a token and get security policy for a specific user.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateToken(token: string, options?: any): AxiosPromise<void> {
      return localVarFp.validateToken(token, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
  /**
   *
   * @summary Retrieve the list of security profiles for a specific service type.
   * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
   * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
   * @param {string} [filter] Filter the results
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public getSecurituProfiles(offset?: number, limit?: number, filter?: string, options?: any) {
    return SecurityApiFp(this.configuration)
      .getSecurituProfiles(offset, limit, filter, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve the basic system information. This information is used between services only.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public getSystemServices(options?: any) {
    return SecurityApiFp(this.configuration)
      .getSystemServices(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Allows any microservice to validate a token and get security policy for a specific user.
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public validateToken(token: string, options?: any) {
    return SecurityApiFp(this.configuration)
      .validateToken(token, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SystemCommandsApi - axios parameter creator
 * @export
 */
export const SystemCommandsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Retrieve different values from the running service.
     * @param {'info'} command Get a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemCommand: async (command: 'info', options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'command' is not null or undefined
      assertParamExists('getSystemCommand', 'command', command);
      const localVarPath = `/system`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (command !== undefined) {
        localVarQueryParameter['command'] = command;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Perform some system wide commands.
     * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemCommand: async (
      systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?:
        | SystemCommandSetLogLevel
        | SystemCommandReload
        | SystemCommandGetLogLevels
        | SystemCommandGetLogLevelNames
        | SystemCommandGetSubsystemNames,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SystemCommandsApi - functional programming interface
 * @export
 */
export const SystemCommandsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemCommandsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Retrieve different values from the running service.
     * @param {'info'} command Get a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystemCommand(
      command: 'info',
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfoResults>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemCommand(command, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Perform some system wide commands.
     * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemCommand(
      systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?:
        | SystemCommandSetLogLevel
        | SystemCommandReload
        | SystemCommandGetLogLevels
        | SystemCommandGetLogLevelNames
        | SystemCommandGetSubsystemNames,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SystemGetLogLevelsResult | SystemCommandGetLogLevelNamesResult | SystemGetSubSystemNemesResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.systemCommand(
        systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SystemCommandsApi - factory interface
 * @export
 */
export const SystemCommandsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SystemCommandsApiFp(configuration);
  return {
    /**
     *
     * @summary Retrieve different values from the running service.
     * @param {'info'} command Get a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemCommand(command: 'info', options?: any): AxiosPromise<SystemInfoResults> {
      return localVarFp.getSystemCommand(command, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Perform some system wide commands.
     * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemCommand(
      systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?:
        | SystemCommandSetLogLevel
        | SystemCommandReload
        | SystemCommandGetLogLevels
        | SystemCommandGetLogLevelNames
        | SystemCommandGetSubsystemNames,
      options?: any,
    ): AxiosPromise<SystemGetLogLevelsResult | SystemCommandGetLogLevelNamesResult | SystemGetSubSystemNemesResult> {
      return localVarFp
        .systemCommand(
          systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames,
          options,
        )
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * SystemCommandsApi - object-oriented interface
 * @export
 * @class SystemCommandsApi
 * @extends {BaseAPI}
 */
export class SystemCommandsApi extends BaseAPI {
  /**
   *
   * @summary Retrieve different values from the running service.
   * @param {'info'} command Get a value
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemCommandsApi
   */
  public getSystemCommand(command: 'info', options?: any) {
    return SystemCommandsApiFp(this.configuration)
      .getSystemCommand(command, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Perform some system wide commands.
   * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemCommandsApi
   */
  public systemCommand(
    systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?:
      | SystemCommandSetLogLevel
      | SystemCommandReload
      | SystemCommandGetLogLevels
      | SystemCommandGetLogLevelNames
      | SystemCommandGetSubsystemNames,
    options?: any,
  ) {
    return SystemCommandsApiFp(this.configuration)
      .systemCommand(
        systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * UserManagementApi - axios parameter creator
 * @export
 */
export const UserManagementApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a single user.
     * @param {number} id
     * @param {boolean} [emailVerification]
     * @param {UserInfo} [userInfo] User details (some fields are ignored during creation)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (
      id: number,
      emailVerification?: boolean,
      userInfo?: UserInfo,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createUser', 'id', id);
      const localVarPath = `/user/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (emailVerification !== undefined) {
        localVarQueryParameter['email_verification'] = emailVerification;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(userInfo, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a single user.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (id: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteUser', 'id', id);
      const localVarPath = `/user/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve the information for a single user.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getUser', 'id', id);
      const localVarPath = `/user/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a list of existing users as well as some information about them.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [filter] Selecting this option means the newest record will be returned. Use limit to select how many.
     * @param {boolean} [idOnly] Return only the ids.
     * @param {string} [select] Return only the ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      offset?: number,
      limit?: number,
      filter?: string,
      idOnly?: boolean,
      select?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (idOnly !== undefined) {
        localVarQueryParameter['idOnly'] = idOnly;
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Modify a single user.
     * @param {number} id
     * @param {boolean} [emailVerification]
     * @param {UserInfo} [userInfo] User details (some fields are ignored during update)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      id: number,
      emailVerification?: boolean,
      userInfo?: UserInfo,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateUser', 'id', id);
      const localVarPath = `/user/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (emailVerification !== undefined) {
        localVarQueryParameter['email_verification'] = emailVerification;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(userInfo, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserManagementApi - functional programming interface
 * @export
 */
export const UserManagementApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserManagementApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a single user.
     * @param {number} id
     * @param {boolean} [emailVerification]
     * @param {UserInfo} [userInfo] User details (some fields are ignored during creation)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      id: number,
      emailVerification?: boolean,
      userInfo?: UserInfo,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(id, emailVerification, userInfo, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete a single user.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      id: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve the information for a single user.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      id: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a list of existing users as well as some information about them.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [filter] Selecting this option means the newest record will be returned. Use limit to select how many.
     * @param {boolean} [idOnly] Return only the ids.
     * @param {string} [select] Return only the ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      offset?: number,
      limit?: number,
      filter?: string,
      idOnly?: boolean,
      select?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        offset,
        limit,
        filter,
        idOnly,
        select,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Modify a single user.
     * @param {number} id
     * @param {boolean} [emailVerification]
     * @param {UserInfo} [userInfo] User details (some fields are ignored during update)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      id: number,
      emailVerification?: boolean,
      userInfo?: UserInfo,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, emailVerification, userInfo, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * UserManagementApi - factory interface
 * @export
 */
export const UserManagementApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserManagementApiFp(configuration);
  return {
    /**
     *
     * @summary Create a single user.
     * @param {number} id
     * @param {boolean} [emailVerification]
     * @param {UserInfo} [userInfo] User details (some fields are ignored during creation)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(id: number, emailVerification?: boolean, userInfo?: UserInfo, options?: any): AxiosPromise<void> {
      return localVarFp.createUser(id, emailVerification, userInfo, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a single user.
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(id: number, options?: any): AxiosPromise<object> {
      return localVarFp.deleteUser(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve the information for a single user.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(id: string, options?: any): AxiosPromise<void> {
      return localVarFp.getUser(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a list of existing users as well as some information about them.
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [filter] Selecting this option means the newest record will be returned. Use limit to select how many.
     * @param {boolean} [idOnly] Return only the ids.
     * @param {string} [select] Return only the ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(
      offset?: number,
      limit?: number,
      filter?: string,
      idOnly?: boolean,
      select?: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .getUsers(offset, limit, filter, idOnly, select, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Modify a single user.
     * @param {number} id
     * @param {boolean} [emailVerification]
     * @param {UserInfo} [userInfo] User details (some fields are ignored during update)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(id: number, emailVerification?: boolean, userInfo?: UserInfo, options?: any): AxiosPromise<void> {
      return localVarFp.updateUser(id, emailVerification, userInfo, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * UserManagementApi - object-oriented interface
 * @export
 * @class UserManagementApi
 * @extends {BaseAPI}
 */
export class UserManagementApi extends BaseAPI {
  /**
   *
   * @summary Create a single user.
   * @param {number} id
   * @param {boolean} [emailVerification]
   * @param {UserInfo} [userInfo] User details (some fields are ignored during creation)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserManagementApi
   */
  public createUser(id: number, emailVerification?: boolean, userInfo?: UserInfo, options?: any) {
    return UserManagementApiFp(this.configuration)
      .createUser(id, emailVerification, userInfo, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a single user.
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserManagementApi
   */
  public deleteUser(id: number, options?: any) {
    return UserManagementApiFp(this.configuration)
      .deleteUser(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve the information for a single user.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserManagementApi
   */
  public getUser(id: string, options?: any) {
    return UserManagementApiFp(this.configuration)
      .getUser(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a list of existing users as well as some information about them.
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {string} [filter] Selecting this option means the newest record will be returned. Use limit to select how many.
   * @param {boolean} [idOnly] Return only the ids.
   * @param {string} [select] Return only the ids.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserManagementApi
   */
  public getUsers(offset?: number, limit?: number, filter?: string, idOnly?: boolean, select?: string, options?: any) {
    return UserManagementApiFp(this.configuration)
      .getUsers(offset, limit, filter, idOnly, select, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Modify a single user.
   * @param {number} id
   * @param {boolean} [emailVerification]
   * @param {UserInfo} [userInfo] User details (some fields are ignored during update)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserManagementApi
   */
  public updateUser(id: number, emailVerification?: boolean, userInfo?: UserInfo, options?: any) {
    return UserManagementApiFp(this.configuration)
      .updateUser(id, emailVerification, userInfo, options)
      .then(request => request(this.axios, this.basePath));
  }
}
