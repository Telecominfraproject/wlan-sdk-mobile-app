/* tslint:disable */
/* eslint-disable */
/**
 * uCentral gateway API
 * A process to manage configuration for devices.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: ucentralsupport@arilia.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AnyPayload
 */
export interface AnyPayload {
    /**
     * 
     * @type {string}
     * @memberof AnyPayload
     */
    Document?: string;
}
/**
 * 
 * @export
 * @interface BlackDeviceInfo
 */
export interface BlackDeviceInfo {
    /**
     * 
     * @type {string}
     * @memberof BlackDeviceInfo
     */
    serialNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof BlackDeviceInfo
     */
    created?: number;
    /**
     * 
     * @type {string}
     * @memberof BlackDeviceInfo
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof BlackDeviceInfo
     */
    reason?: string;
}
/**
 * 
 * @export
 * @interface BlackDeviceList
 */
export interface BlackDeviceList {
    /**
     * 
     * @type {Array<BlackDeviceInfo>}
     * @memberof BlackDeviceList
     */
    devices?: Array<BlackDeviceInfo>;
}
/**
 * 
 * @export
 * @interface CapabilitiesModel
 */
export interface CapabilitiesModel {
    /**
     * 
     * @type {string}
     * @memberof CapabilitiesModel
     */
    deviceType?: string;
    /**
     * 
     * @type {string}
     * @memberof CapabilitiesModel
     */
    capabilities?: string;
}
/**
 * 
 * @export
 * @interface CapabilitiesModelList
 */
export interface CapabilitiesModelList {
    /**
     * 
     * @type {Array<CapabilitiesModel>}
     * @memberof CapabilitiesModelList
     */
    devices?: Array<CapabilitiesModel>;
}
/**
 * 
 * @export
 * @interface CommandDetails
 */
export interface CommandDetails {
    /**
     * 
     * @type {string}
     * @memberof CommandDetails
     */
    command?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandDetails
     */
    payload?: string;
    /**
     * 
     * @type {number}
     * @memberof CommandDetails
     */
    when?: number;
    /**
     * 
     * @type {string}
     * @memberof CommandDetails
     */
    serialNumber?: string;
}
/**
 * 
 * @export
 * @interface CommandInfo
 */
export interface CommandInfo {
    /**
     * 
     * @type {string}
     * @memberof CommandInfo
     */
    UUID?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandInfo
     */
    command?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandInfo
     */
    details?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandInfo
     */
    serialNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof CommandInfo
     */
    submitted?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandInfo
     */
    executed?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandInfo
     */
    completed?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandInfo
     */
    when?: number;
    /**
     * 
     * @type {string}
     * @memberof CommandInfo
     */
    errorText?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandInfo
     */
    results?: string;
    /**
     * 
     * @type {number}
     * @memberof CommandInfo
     */
    errorCode?: number;
    /**
     * 
     * @type {string}
     * @memberof CommandInfo
     */
    submittedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandInfo
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof CommandInfo
     */
    custom?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandInfo
     */
    waitingForFile?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandInfo
     */
    attachFile?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandInfo
     */
    attachSize?: number;
    /**
     * 
     * @type {string}
     * @memberof CommandInfo
     */
    attachType?: string;
}
/**
 * 
 * @export
 * @interface CommandInfoList
 */
export interface CommandInfoList {
    /**
     * 
     * @type {Array<CommandInfo>}
     * @memberof CommandInfoList
     */
    commands?: Array<CommandInfo>;
}
/**
 * The command was submitted succesfully.
 * @export
 * @interface CommandSubmitSuccess
 */
export interface CommandSubmitSuccess {
    /**
     * 
     * @type {string}
     * @memberof CommandSubmitSuccess
     */
    serialNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandSubmitSuccess
     */
    UUID?: string;
}
/**
 * 
 * @export
 * @interface DefaultConfiguration
 */
export interface DefaultConfiguration {
    /**
     * 
     * @type {string}
     * @memberof DefaultConfiguration
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DefaultConfiguration
     */
    modelIds?: string;
    /**
     * 
     * @type {string}
     * @memberof DefaultConfiguration
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof DefaultConfiguration
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof DefaultConfiguration
     */
    created?: number;
    /**
     * 
     * @type {number}
     * @memberof DefaultConfiguration
     */
    lastModified?: number;
}
/**
 * 
 * @export
 * @interface DefaultConfigurationList
 */
export interface DefaultConfigurationList {
    /**
     * 
     * @type {Array<DefaultConfiguration>}
     * @memberof DefaultConfigurationList
     */
    configurations?: Array<DefaultConfiguration>;
}
/**
 * Definition of uCentral device
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    venue?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    serialNumber?: string;
    /**
     * 
     * @type {DeviceType}
     * @memberof Device
     */
    deviceType: DeviceType;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    macAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    manufacturer?: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    UUID?: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    configuration?: string;
    /**
     * 
     * @type {Array<NoteInfo>}
     * @memberof Device
     */
    notes?: Array<NoteInfo>;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    createdTimestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    lastConfigurationChange?: number;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    lastConfigurationDownload?: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    firmware?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    devicePassword?: string;
}
/**
 * Describes the capabilities a device can support.
 * @export
 * @interface DeviceCapabilities
 */
export interface DeviceCapabilities {
    /**
     * 
     * @type {string}
     * @memberof DeviceCapabilities
     */
    serialNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCapabilities
     */
    capabilities?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceCapabilities
     */
    lastUpdate?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceCapabilities
     */
    firstUpdate?: number;
}
/**
 * 
 * @export
 * @interface DeviceConfigureRequest
 */
export interface DeviceConfigureRequest {
    /**
     * 
     * @type {string}
     * @memberof DeviceConfigureRequest
     */
    serialNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceConfigureRequest
     */
    UUID?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceConfigureRequest
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceConfigureRequest
     */
    when?: number;
}
/**
 * The number of devices in the DB.
 * @export
 * @interface DeviceCount
 */
export interface DeviceCount {
    /**
     * 
     * @type {number}
     * @memberof DeviceCount
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface DeviceDashboard
 */
export interface DeviceDashboard {
    /**
     * 
     * @type {number}
     * @memberof DeviceDashboard
     */
    snapshot?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceDashboard
     */
    numberOfDevices?: number;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    commands?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    upTimes?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    memoryUsed?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    load1?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    load5?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    load15?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    vendors?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    status?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    type?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    deviceType?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    healths?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    certificates?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    lastContact?: TagIntPairList;
    /**
     * 
     * @type {TagIntPairList}
     * @memberof DeviceDashboard
     */
    associations?: TagIntPairList;
}
/**
 * Definition of uCentral device list
 * @export
 * @interface DeviceList
 */
export interface DeviceList {
    /**
     * 
     * @type {Array<Device>}
     * @memberof DeviceList
     */
    devices?: Array<Device>;
}
/**
 * Definition of uCentral device list including device status.
 * @export
 * @interface DeviceListWithStatus
 */
export interface DeviceListWithStatus {
    /**
     * 
     * @type {Array<DeviceWithStatus>}
     * @memberof DeviceListWithStatus
     */
    devicesWithStatus?: Array<DeviceWithStatus>;
}
/**
 * 
 * @export
 * @interface DeviceLog
 */
export interface DeviceLog {
    /**
     * 
     * @type {string}
     * @memberof DeviceLog
     */
    log?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceLog
     */
    recorded?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceLog
     */
    severity?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceLog
     */
    data?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceLog
     */
    logType?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceLog
     */
    UUID?: number;
}
/**
 * 
 * @export
 * @interface DeviceLogList
 */
export interface DeviceLogList {
    /**
     * 
     * @type {string}
     * @memberof DeviceLogList
     */
    serialNumber?: string;
    /**
     * 
     * @type {Array<DeviceLog>}
     * @memberof DeviceLogList
     */
    values?: Array<DeviceLog>;
}
/**
 * Current device status.
 * @export
 * @interface DeviceStatus
 */
export interface DeviceStatus {
    /**
     * 
     * @type {string}
     * @memberof DeviceStatus
     */
    serialNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceStatus
     */
    ipAddress?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceStatus
     */
    txBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceStatus
     */
    rxBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceStatus
     */
    messageCount?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceStatus
     */
    UUID?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceStatus
     */
    connected?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DeviceStatus
     */
    lastContact?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceStatus
     */
    firmware?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceStatus
     */
    associations_2G?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceStatus
     */
    associations_5G?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceStatus
     */
    verifiedCertificate?: DeviceStatusVerifiedCertificateEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DeviceStatusVerifiedCertificateEnum {
    NoCertificate = 'NO_CERTIFICATE,',
    ValidCertificate = 'VALID_CERTIFICATE,',
    MismatchSerial = 'MISMATCH_SERIAL,',
    Verified = 'VERIFIED'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum DeviceType {
    Ap = 'AP',
    Switch = 'SWITCH',
    Iot = 'IOT',
    Mesh = 'MESH'
}

/**
 * Definition of uCentral device
 * @export
 * @interface DeviceWithStatus
 */
export interface DeviceWithStatus {
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    venue?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    serialNumber?: string;
    /**
     * 
     * @type {DeviceType}
     * @memberof DeviceWithStatus
     */
    deviceType: DeviceType;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    macAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    manufacturer?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithStatus
     */
    UUID?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    configuration?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    compatible?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    fwUpdatePolicy?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    notes?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithStatus
     */
    createdTimestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithStatus
     */
    lastConfigurationChange?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithStatus
     */
    lastConfigurationDownload?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithStatus
     */
    lastFWUpdate?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    firmware?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceWithStatus
     */
    connected?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    ipAddress?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithStatus
     */
    txBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithStatus
     */
    rxBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithStatus
     */
    associations_2G?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithStatus
     */
    associations_5G?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithStatus
     */
    devicePassword?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithStatus
     */
    lastContact?: number;
}
/**
 * 
 * @export
 * @interface EventQueueRequest
 */
export interface EventQueueRequest {
    /**
     * 
     * @type {string}
     * @memberof EventQueueRequest
     */
    serialNumber?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventQueueRequest
     */
    types?: Array<EventQueueRequestTypesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum EventQueueRequestTypesEnum {
    Dhcp = 'dhcp',
    Rrm = 'rrm'
}

/**
 * 
 * @export
 * @interface EventQueueResponse
 */
export interface EventQueueResponse {
    /**
     * 
     * @type {string}
     * @memberof EventQueueResponse
     */
    serialNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof EventQueueResponse
     */
    UUID?: string;
    /**
     * 
     * @type {string}
     * @memberof EventQueueResponse
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface FactoryRequest
 */
export interface FactoryRequest {
    /**
     * 
     * @type {string}
     * @memberof FactoryRequest
     */
    serialNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof FactoryRequest
     */
    when?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FactoryRequest
     */
    keepRedirector?: boolean;
}
/**
 * 
 * @export
 * @interface HealthCheck
 */
export interface HealthCheck {
    /**
     * 
     * @type {number}
     * @memberof HealthCheck
     */
    UUID?: number;
    /**
     * 
     * @type {number}
     * @memberof HealthCheck
     */
    sanity?: number;
    /**
     * 
     * @type {string}
     * @memberof HealthCheck
     */
    data?: string;
    /**
     * 
     * @type {number}
     * @memberof HealthCheck
     */
    recorded?: number;
}
/**
 * 
 * @export
 * @interface HealthCheckList
 */
export interface HealthCheckList {
    /**
     * 
     * @type {string}
     * @memberof HealthCheckList
     */
    serialNumber?: string;
    /**
     * 
     * @type {Array<HealthCheck>}
     * @memberof HealthCheckList
     */
    values?: Array<HealthCheck>;
}
/**
 * 
 * @export
 * @interface InterfaceStatistics
 */
export interface InterfaceStatistics {
    /**
     * 
     * @type {string}
     * @memberof InterfaceStatistics
     */
    name?: string;
    /**
     * 
     * @type {Array<NameValuePair>}
     * @memberof InterfaceStatistics
     */
    values?: Array<NameValuePair>;
}
/**
 * 
 * @export
 * @interface LEDsRequest
 */
export interface LEDsRequest {
    /**
     * 
     * @type {string}
     * @memberof LEDsRequest
     */
    serialNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof LEDsRequest
     */
    when?: number;
    /**
     * only applies to the blink pattern
     * @type {number}
     * @memberof LEDsRequest
     */
    duration?: number;
    /**
     * 
     * @type {string}
     * @memberof LEDsRequest
     */
    pattern?: LEDsRequestPatternEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum LEDsRequestPatternEnum {
    True = 'true',
    False = 'false',
    Blink = 'blink'
}

/**
 * 
 * @export
 * @interface LifetimeStatistics
 */
export interface LifetimeStatistics {
    /**
     * 
     * @type {string}
     * @memberof LifetimeStatistics
     */
    serialNumber?: string;
    /**
     * 
     * @type {Array<InterfaceStatistics>}
     * @memberof LifetimeStatistics
     */
    interfaces?: Array<InterfaceStatistics>;
}
/**
 * 
 * @export
 * @interface MessageRequest
 */
export interface MessageRequest {
    /**
     * 
     * @type {string}
     * @memberof MessageRequest
     */
    serialNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof MessageRequest
     */
    when?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageRequest
     */
    message?: MessageRequestMessageEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum MessageRequestMessageEnum {
    State = 'state',
    Healthcheck = 'healthcheck'
}

/**
 * 
 * @export
 * @interface NameValuePair
 */
export interface NameValuePair {
    /**
     * 
     * @type {string}
     * @memberof NameValuePair
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof NameValuePair
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface NoteInfo
 */
export interface NoteInfo {
    /**
     * 
     * @type {number}
     * @memberof NoteInfo
     */
    created?: number;
    /**
     * 
     * @type {string}
     * @memberof NoteInfo
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof NoteInfo
     */
    note?: string;
}
/**
 * 
 * @export
 * @interface RebootRequest
 */
export interface RebootRequest {
    /**
     * 
     * @type {string}
     * @memberof RebootRequest
     */
    serialNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof RebootRequest
     */
    when?: number;
}
/**
 * 
 * @export
 * @interface RttySessionDetails
 */
export interface RttySessionDetails {
    /**
     * 
     * @type {string}
     * @memberof RttySessionDetails
     */
    serialNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof RttySessionDetails
     */
    server?: string;
    /**
     * 
     * @type {number}
     * @memberof RttySessionDetails
     */
    port?: number;
    /**
     * 
     * @type {string}
     * @memberof RttySessionDetails
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof RttySessionDetails
     */
    timeout?: number;
    /**
     * 
     * @type {string}
     * @memberof RttySessionDetails
     */
    connectionId?: string;
    /**
     * 
     * @type {number}
     * @memberof RttySessionDetails
     */
    started?: number;
    /**
     * 
     * @type {string}
     * @memberof RttySessionDetails
     */
    commandUUID?: string;
    /**
     * 
     * @type {number}
     * @memberof RttySessionDetails
     */
    viewport?: number;
    /**
     * 
     * @type {string}
     * @memberof RttySessionDetails
     */
    password?: string;
}
/**
 * List of serial numbers.
 * @export
 * @interface SerialNumberList
 */
export interface SerialNumberList {
    /**
     * 
     * @type {Array<string>}
     * @memberof SerialNumberList
     */
    serialNumbers?: Array<string>;
}
/**
 * 
 * @export
 * @interface StatisticsDetails
 */
export interface StatisticsDetails {
    /**
     * 
     * @type {string}
     * @memberof StatisticsDetails
     */
    serialNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof StatisticsDetails
     */
    recorded?: number;
    /**
     * 
     * @type {number}
     * @memberof StatisticsDetails
     */
    UUID?: number;
    /**
     * 
     * @type {string}
     * @memberof StatisticsDetails
     */
    data?: string;
}
/**
 * 
 * @export
 * @interface StatisticsRecords
 */
export interface StatisticsRecords {
    /**
     * 
     * @type {string}
     * @memberof StatisticsRecords
     */
    serialNumber?: string;
    /**
     * 
     * @type {Array<StatisticsDetails>}
     * @memberof StatisticsRecords
     */
    values?: Array<StatisticsDetails>;
}
/**
 * 
 * @export
 * @interface StringList
 */
export interface StringList {
    /**
     * 
     * @type {Array<string>}
     * @memberof StringList
     */
    list?: Array<string>;
}
/**
 * 
 * @export
 * @interface SystemCommandDetails
 */
export interface SystemCommandDetails {
    /**
     * 
     * @type {string}
     * @memberof SystemCommandDetails
     */
    command?: SystemCommandDetailsCommandEnum;
    /**
     * 
     * @type {StringList | TagValuePairList}
     * @memberof SystemCommandDetails
     */
    parameters?: StringList | TagValuePairList;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemCommandDetailsCommandEnum {
    Setloglevels = 'setloglevels',
    Getloglevels = 'getloglevels',
    GetSubSystemNames = 'getSubSystemNames',
    GetLogLevelNames = 'getLogLevelNames',
    Stats = 'stats'
}

/**
 * 
 * @export
 * @interface SystemCommandGetLogLevelNames
 */
export interface SystemCommandGetLogLevelNames {
    /**
     * 
     * @type {string}
     * @memberof SystemCommandGetLogLevelNames
     */
    command?: SystemCommandGetLogLevelNamesCommandEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemCommandGetLogLevelNamesCommandEnum {
    Getloglevelnames = 'getloglevelnames'
}

/**
 * 
 * @export
 * @interface SystemCommandGetLogLevelNamesResult
 */
export interface SystemCommandGetLogLevelNamesResult {
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemCommandGetLogLevelNamesResult
     */
    list?: Array<string>;
}
/**
 * 
 * @export
 * @interface SystemCommandGetLogLevels
 */
export interface SystemCommandGetLogLevels {
    /**
     * 
     * @type {string}
     * @memberof SystemCommandGetLogLevels
     */
    command?: SystemCommandGetLogLevelsCommandEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemCommandGetLogLevelsCommandEnum {
    Getloglevels = 'getloglevels'
}

/**
 * 
 * @export
 * @interface SystemCommandGetSubsystemNames
 */
export interface SystemCommandGetSubsystemNames {
    /**
     * 
     * @type {string}
     * @memberof SystemCommandGetSubsystemNames
     */
    command?: SystemCommandGetSubsystemNamesCommandEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemCommandGetSubsystemNamesCommandEnum {
    Getsubsystemnames = 'getsubsystemnames'
}

/**
 * 
 * @export
 * @interface SystemCommandReload
 */
export interface SystemCommandReload {
    /**
     * 
     * @type {string}
     * @memberof SystemCommandReload
     */
    command?: SystemCommandReloadCommandEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemCommandReload
     */
    subsystems?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemCommandReloadCommandEnum {
    Reload = 'reload'
}

/**
 * @type SystemCommandResults
 * @export
 */
export type SystemCommandResults = StringList | TagValuePairList;

/**
 * 
 * @export
 * @interface SystemCommandSetLogLevel
 */
export interface SystemCommandSetLogLevel {
    /**
     * 
     * @type {string}
     * @memberof SystemCommandSetLogLevel
     */
    command?: SystemCommandSetLogLevelCommandEnum;
    /**
     * 
     * @type {Array<TagValuePair>}
     * @memberof SystemCommandSetLogLevel
     */
    subsystems?: Array<TagValuePair>;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemCommandSetLogLevelCommandEnum {
    Setloglevel = 'setloglevel'
}

/**
 * 
 * @export
 * @interface SystemGetLogLevelsResult
 */
export interface SystemGetLogLevelsResult {
    /**
     * 
     * @type {Array<TagValuePair>}
     * @memberof SystemGetLogLevelsResult
     */
    taglist?: Array<TagValuePair>;
}
/**
 * 
 * @export
 * @interface SystemGetSubSystemNamesResult
 */
export interface SystemGetSubSystemNamesResult {
    /**
     * 
     * @type {Array<TagValuePair>}
     * @memberof SystemGetSubSystemNamesResult
     */
    taglist?: Array<TagValuePair>;
}
/**
 * 
 * @export
 * @interface SystemInfoResults
 */
export interface SystemInfoResults {
    /**
     * 
     * @type {string}
     * @memberof SystemInfoResults
     */
    version?: string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoResults
     */
    uptime?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoResults
     */
    start?: number;
    /**
     * 
     * @type {string}
     * @memberof SystemInfoResults
     */
    os?: string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoResults
     */
    processors?: number;
    /**
     * 
     * @type {string}
     * @memberof SystemInfoResults
     */
    hostname?: string;
    /**
     * 
     * @type {Array<SystemInfoResultsCertificates>}
     * @memberof SystemInfoResults
     */
    certificates?: Array<SystemInfoResultsCertificates>;
}
/**
 * 
 * @export
 * @interface SystemInfoResultsCertificates
 */
export interface SystemInfoResultsCertificates {
    /**
     * 
     * @type {string}
     * @memberof SystemInfoResultsCertificates
     */
    filename?: string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoResultsCertificates
     */
    expires?: number;
}
/**
 * 
 * @export
 * @interface TagIntPair
 */
export interface TagIntPair {
    /**
     * 
     * @type {string}
     * @memberof TagIntPair
     */
    tag?: string;
    /**
     * 
     * @type {number}
     * @memberof TagIntPair
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface TagIntPairList
 */
export interface TagIntPairList {
    /**
     * 
     * @type {Array<TagIntPair>}
     * @memberof TagIntPairList
     */
    tagList?: Array<TagIntPair>;
}
/**
 * 
 * @export
 * @interface TagValuePair
 */
export interface TagValuePair {
    /**
     * 
     * @type {string}
     * @memberof TagValuePair
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof TagValuePair
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface TagValuePairList
 */
export interface TagValuePairList {
    /**
     * 
     * @type {Array<TagValuePair>}
     * @memberof TagValuePairList
     */
    tagList?: Array<TagValuePair>;
}
/**
 * 
 * @export
 * @interface TelemetryStreamRequest
 */
export interface TelemetryStreamRequest {
    /**
     * 
     * @type {string}
     * @memberof TelemetryStreamRequest
     */
    serialNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof TelemetryStreamRequest
     */
    interval?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TelemetryStreamRequest
     */
    types?: Array<TelemetryStreamRequestTypesEnum>;
    /**
     * 
     * @type {string}
     * @memberof TelemetryStreamRequest
     */
    uuid?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TelemetryStreamRequestTypesEnum {
    DhcpSnooping = 'dhcp-snooping',
    WireFrames = 'wire-frames',
    State = 'state'
}

/**
 * 
 * @export
 * @interface TelemetryStreamResponse
 */
export interface TelemetryStreamResponse {
    /**
     * 
     * @type {string}
     * @memberof TelemetryStreamResponse
     */
    serialNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TelemetryStreamResponse
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof TelemetryStreamResponse
     */
    uri?: string;
}
/**
 * 
 * @export
 * @interface TraceRequest
 */
export interface TraceRequest {
    /**
     * 
     * @type {string}
     * @memberof TraceRequest
     */
    serialNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof TraceRequest
     */
    when?: number;
    /**
     * 
     * @type {number}
     * @memberof TraceRequest
     */
    duration?: number;
    /**
     * 
     * @type {number}
     * @memberof TraceRequest
     */
    numberOfPackets?: number;
    /**
     * 
     * @type {string}
     * @memberof TraceRequest
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof TraceRequest
     */
    _interface?: string;
}
/**
 * 
 * @export
 * @interface UpgradeRequest
 */
export interface UpgradeRequest {
    /**
     * 
     * @type {string}
     * @memberof UpgradeRequest
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof UpgradeRequest
     */
    serialNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof UpgradeRequest
     */
    when?: number;
}
/**
 * 
 * @export
 * @interface WifiBands
 */
export interface WifiBands {
    /**
     * 
     * @type {Array<string>}
     * @memberof WifiBands
     */
    bands?: Array<WifiBandsBandsEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum WifiBandsBandsEnum {
    _2 = '2',
    _5 = '5',
    _5l = '5l',
    _5u = '5u',
    _6 = '6'
}

/**
 * 
 * @export
 * @interface WifiChannels
 */
export interface WifiChannels {
    /**
     * 
     * @type {Array<number>}
     * @memberof WifiChannels
     */
    channels?: Array<number>;
}
/**
 * 
 * @export
 * @interface WifiScanRequest
 */
export interface WifiScanRequest {
    /**
     * 
     * @type {string}
     * @memberof WifiScanRequest
     */
    serialNumber: string;
    /**
     * 
     * @type {boolean}
     * @memberof WifiScanRequest
     */
    verbose?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WifiScanRequest
     */
    activeScan?: boolean;
    /**
     * 
     * @type {WifiBands | WifiChannels}
     * @memberof WifiScanRequest
     */
    selector?: WifiBands | WifiChannels;
}

/**
 * BlacklistApi - axios parameter creator
 * @export
 */
export const BlacklistApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create to the blacklist
         * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {BlackDeviceInfo} [blackDeviceInfo] Add blacklisted device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlackListDevice: async (serialNumber: string, blackDeviceInfo?: BlackDeviceInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('createBlackListDevice', 'serialNumber', serialNumber)
            const localVarPath = `/blacklist/{serialNumber}`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blackDeviceInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete from the blacklist
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFromBlackList: async (serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('deleteFromBlackList', 'serialNumber', serialNumber)
            const localVarPath = `/blacklist/{serialNumber}`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of blacklisteddevices.
         * @summary Returns a blacklist entry
         * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlacklistDevice: async (serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('getBlacklistDevice', 'serialNumber', serialNumber)
            const localVarPath = `/blacklist/{serialNumber}`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of blacklisteddevices.
         * @summary Returns a list blacklisted devices.
         * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
         * @param {string} [filter] Filter the results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlacklistDeviceList: async (offset?: number, limit?: number, filter?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/blacklist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify to the blacklist
         * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {BlackDeviceInfo} [blackDeviceInfo] Add blacklisted devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBlackList: async (serialNumber: string, blackDeviceInfo?: BlackDeviceInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('modifyBlackList', 'serialNumber', serialNumber)
            const localVarPath = `/blacklist/{serialNumber}`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blackDeviceInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlacklistApi - functional programming interface
 * @export
 */
export const BlacklistApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlacklistApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create to the blacklist
         * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {BlackDeviceInfo} [blackDeviceInfo] Add blacklisted device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBlackListDevice(serialNumber: string, blackDeviceInfo?: BlackDeviceInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBlackListDevice(serialNumber, blackDeviceInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete from the blacklist
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFromBlackList(serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFromBlackList(serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of blacklisteddevices.
         * @summary Returns a blacklist entry
         * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlacklistDevice(serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlackDeviceInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlacklistDevice(serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of blacklisteddevices.
         * @summary Returns a list blacklisted devices.
         * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
         * @param {string} [filter] Filter the results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlacklistDeviceList(offset?: number, limit?: number, filter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlackDeviceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlacklistDeviceList(offset, limit, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify to the blacklist
         * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {BlackDeviceInfo} [blackDeviceInfo] Add blacklisted devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyBlackList(serialNumber: string, blackDeviceInfo?: BlackDeviceInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyBlackList(serialNumber, blackDeviceInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlacklistApi - factory interface
 * @export
 */
export const BlacklistApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlacklistApiFp(configuration)
    return {
        /**
         * 
         * @summary Create to the blacklist
         * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {BlackDeviceInfo} [blackDeviceInfo] Add blacklisted device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlackListDevice(serialNumber: string, blackDeviceInfo?: BlackDeviceInfo, options?: any): AxiosPromise<object> {
            return localVarFp.createBlackListDevice(serialNumber, blackDeviceInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete from the blacklist
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFromBlackList(serialNumber: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteFromBlackList(serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of blacklisteddevices.
         * @summary Returns a blacklist entry
         * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlacklistDevice(serialNumber: string, options?: any): AxiosPromise<BlackDeviceInfo> {
            return localVarFp.getBlacklistDevice(serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of blacklisteddevices.
         * @summary Returns a list blacklisted devices.
         * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
         * @param {string} [filter] Filter the results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlacklistDeviceList(offset?: number, limit?: number, filter?: string, options?: any): AxiosPromise<BlackDeviceList> {
            return localVarFp.getBlacklistDeviceList(offset, limit, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify to the blacklist
         * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {BlackDeviceInfo} [blackDeviceInfo] Add blacklisted devices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBlackList(serialNumber: string, blackDeviceInfo?: BlackDeviceInfo, options?: any): AxiosPromise<object> {
            return localVarFp.modifyBlackList(serialNumber, blackDeviceInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlacklistApi - object-oriented interface
 * @export
 * @class BlacklistApi
 * @extends {BaseAPI}
 */
export class BlacklistApi extends BaseAPI {
    /**
     * 
     * @summary Create to the blacklist
     * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {BlackDeviceInfo} [blackDeviceInfo] Add blacklisted device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlacklistApi
     */
    public createBlackListDevice(serialNumber: string, blackDeviceInfo?: BlackDeviceInfo, options?: any) {
        return BlacklistApiFp(this.configuration).createBlackListDevice(serialNumber, blackDeviceInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete from the blacklist
     * @param {string} serialNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlacklistApi
     */
    public deleteFromBlackList(serialNumber: string, options?: any) {
        return BlacklistApiFp(this.configuration).deleteFromBlackList(serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of blacklisteddevices.
     * @summary Returns a blacklist entry
     * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlacklistApi
     */
    public getBlacklistDevice(serialNumber: string, options?: any) {
        return BlacklistApiFp(this.configuration).getBlacklistDevice(serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of blacklisteddevices.
     * @summary Returns a list blacklisted devices.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlacklistApi
     */
    public getBlacklistDeviceList(offset?: number, limit?: number, filter?: string, options?: any) {
        return BlacklistApiFp(this.configuration).getBlacklistDeviceList(offset, limit, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify to the blacklist
     * @param {string} serialNumber Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {BlackDeviceInfo} [blackDeviceInfo] Add blacklisted devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlacklistApi
     */
    public modifyBlackList(serialNumber: string, blackDeviceInfo?: BlackDeviceInfo, options?: any) {
        return BlacklistApiFp(this.configuration).modifyBlackList(serialNumber, blackDeviceInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommandsApi - axios parameter creator
 * @export
 */
export const CommandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a specific command
         * @summary Delete a specific command
         * @param {string} commandUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACommand: async (commandUUID: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'commandUUID' is not null or undefined
            assertParamExists('deleteACommand', 'commandUUID', commandUUID)
            const localVarPath = `/command/{commandUUID}`
                .replace(`{${"commandUUID"}}`, encodeURIComponent(String(commandUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete some commands
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommands: async (serialNumber: string, startDate?: number, endDate?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('deleteCommands', 'serialNumber', serialNumber)
            const localVarPath = `/commands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (serialNumber !== undefined) {
                localVarQueryParameter['serialNumber'] = serialNumber;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the capabilities for a given device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceCapabilities: async (serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('deleteDeviceCapabilities', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/capabilities`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete some device health checks
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceHealthChecks: async (serialNumber: string, startDate?: number, endDate?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('deleteDeviceHealthChecks', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/healthchecks`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete some device logs
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [logType] 0&#x3D;any kind of logs (default) 1&#x3D;normal logs only 2&#x3D;crash logs only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceLogs: async (serialNumber: string, startDate?: number, endDate?: number, logType?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('deleteDeviceLogs', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/logs`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (logType !== undefined) {
                localVarQueryParameter['logType'] = logType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest statistics for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceStats: async (serialNumber: string, startDate?: number, endDate?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('deleteDeviceStats', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/statistics`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request a list of queued events
         * @param {string} serialNumber 
         * @param {EventQueueRequest} [eventQueueRequest] Message request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventQueueRequest: async (serialNumber: string, eventQueueRequest?: EventQueueRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('eventQueueRequest', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/eventqueue`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventQueueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request a telemetry stream
         * @param {string} serialNumber 
         * @param {TelemetryStreamRequest} [telemetryStreamRequest] Message request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTelemetryStreamRequest: async (serialNumber: string, telemetryStreamRequest?: TelemetryStreamRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('eventTelemetryStreamRequest', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/telemetry`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(telemetryStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a command to a device
         * @param {string} serialNumber 
         * @param {CommandDetails} [commandDetails] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeCommand: async (serialNumber: string, commandDetails?: CommandDetails, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('executeCommand', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/command`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commandDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Factory reset a device a device
         * @param {string} serialNumber 
         * @param {FactoryRequest} [factoryRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        factoryReset: async (serialNumber: string, factoryRequest?: FactoryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('factoryReset', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/factory`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(factoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific command
         * @summary Returns a specific command
         * @param {string} commandUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACommandDetails: async (commandUUID: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'commandUUID' is not null or undefined
            assertParamExists('getACommandDetails', 'commandUUID', commandUUID)
            const localVarPath = `/command/{commandUUID}`
                .replace(`{${"commandUUID"}}`, encodeURIComponent(String(commandUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of commands.
         * @summary Returns a list of commands.
         * @param {string} [serialNumber] 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandList: async (serialNumber?: string, startDate?: number, endDate?: number, offset?: number, limit?: number, newest?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/commands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (serialNumber !== undefined) {
                localVarQueryParameter['serialNumber'] = serialNumber;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (newest !== undefined) {
                localVarQueryParameter['newest'] = newest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest capabilities for a given device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceCapabilities: async (serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('getDeviceCapabilities', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/capabilities`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest health checks for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {boolean} [lastOnly] Selecting this option means the last healthcheck will be returned. All other parameters will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceHealthChecks: async (serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, newest?: boolean, lastOnly?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('getDeviceHealthChecks', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/healthchecks`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (newest !== undefined) {
                localVarQueryParameter['newest'] = newest;
            }

            if (lastOnly !== undefined) {
                localVarQueryParameter['lastOnly'] = lastOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest logs for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {number} [logType] 0&#x3D;any kind of logs (default) 0&#x3D;normal logs only 1&#x3D;crash logs only
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceLogs: async (serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, logType?: number, newest?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('getDeviceLogs', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/logs`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (logType !== undefined) {
                localVarQueryParameter['logType'] = logType;
            }

            if (newest !== undefined) {
                localVarQueryParameter['newest'] = newest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest statistics for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [lifetime] Selecting this option means the LifetimeStatistics will be returned. All other parameters will be ignored.
         * @param {boolean} [lastOnly] Selecting this option means the LifetimeStatistics will be returned. All other parameters will be ignored.
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceStats: async (serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, lifetime?: boolean, lastOnly?: boolean, newest?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('getDeviceStats', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/statistics`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (lifetime !== undefined) {
                localVarQueryParameter['lifetime'] = lifetime;
            }

            if (lastOnly !== undefined) {
                localVarQueryParameter['lastOnly'] = lastOnly;
            }

            if (newest !== undefined) {
                localVarQueryParameter['newest'] = newest;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest status for a given device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceStatus: async (serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('getDeviceStatus', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/status`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the rtty parameters to initiate a session
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRttySessionInfo: async (serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('getRttySessionInfo', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/rtty`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Blink the LEDs on a device
         * @param {string} serialNumber 
         * @param {LEDsRequest} [lEDsRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledsRequest: async (serialNumber: string, lEDsRequest?: LEDsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('ledsRequest', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/leds`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lEDsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request a specific message
         * @param {string} serialNumber 
         * @param {MessageRequest} [messageRequest] Message request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageRequest: async (serialNumber: string, messageRequest?: MessageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('messageRequest', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/request`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upgrade a device
         * @param {string} serialNumber 
         * @param {RebootRequest} [rebootRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootDevice: async (serialNumber: string, rebootRequest?: RebootRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('rebootDevice', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/reboot`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rebootRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch a trace for a device
         * @param {string} serialNumber 
         * @param {TraceRequest} [traceRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        traceRequest: async (serialNumber: string, traceRequest?: TraceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('traceRequest', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/trace`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(traceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Configura a device
         * @param {string} serialNumber 
         * @param {DeviceConfigureRequest} [deviceConfigureRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationForADevice: async (serialNumber: string, deviceConfigureRequest?: DeviceConfigureRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('updateConfigurationForADevice', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/configure`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceConfigureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upgrade a device
         * @param {string} serialNumber 
         * @param {UpgradeRequest} [upgradeRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeDeviceFirmware: async (serialNumber: string, upgradeRequest?: UpgradeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('upgradeDeviceFirmware', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/upgrade`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch a wifi scan for a device
         * @param {string} serialNumber 
         * @param {WifiScanRequest} [wifiScanRequest] Scan details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wifiscanRequest: async (serialNumber: string, wifiScanRequest?: WifiScanRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('wifiscanRequest', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}/wifiscan`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wifiScanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandsApi - functional programming interface
 * @export
 */
export const CommandsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommandsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a specific command
         * @summary Delete a specific command
         * @param {string} commandUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteACommand(commandUUID: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteACommand(commandUUID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete some commands
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCommands(serialNumber: string, startDate?: number, endDate?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCommands(serialNumber, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the capabilities for a given device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceCapabilities(serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceCapabilities(serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete some device health checks
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceHealthChecks(serialNumber: string, startDate?: number, endDate?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceHealthChecks(serialNumber, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete some device logs
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [logType] 0&#x3D;any kind of logs (default) 1&#x3D;normal logs only 2&#x3D;crash logs only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceLogs(serialNumber: string, startDate?: number, endDate?: number, logType?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceLogs(serialNumber, startDate, endDate, logType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the latest statistics for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceStats(serialNumber: string, startDate?: number, endDate?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceStats(serialNumber, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request a list of queued events
         * @param {string} serialNumber 
         * @param {EventQueueRequest} [eventQueueRequest] Message request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventQueueRequest(serialNumber: string, eventQueueRequest?: EventQueueRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventQueueRequest(serialNumber, eventQueueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request a telemetry stream
         * @param {string} serialNumber 
         * @param {TelemetryStreamRequest} [telemetryStreamRequest] Message request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTelemetryStreamRequest(serialNumber: string, telemetryStreamRequest?: TelemetryStreamRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTelemetryStreamRequest(serialNumber, telemetryStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post a command to a device
         * @param {string} serialNumber 
         * @param {CommandDetails} [commandDetails] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeCommand(serialNumber: string, commandDetails?: CommandDetails, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeCommand(serialNumber, commandDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Factory reset a device a device
         * @param {string} serialNumber 
         * @param {FactoryRequest} [factoryRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async factoryReset(serialNumber: string, factoryRequest?: FactoryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.factoryReset(serialNumber, factoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific command
         * @summary Returns a specific command
         * @param {string} commandUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getACommandDetails(commandUUID: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getACommandDetails(commandUUID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of commands.
         * @summary Returns a list of commands.
         * @param {string} [serialNumber] 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommandList(serialNumber?: string, startDate?: number, endDate?: number, offset?: number, limit?: number, newest?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandInfoList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommandList(serialNumber, startDate, endDate, offset, limit, newest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the latest capabilities for a given device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceCapabilities(serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceCapabilities>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceCapabilities(serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the latest health checks for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {boolean} [lastOnly] Selecting this option means the last healthcheck will be returned. All other parameters will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceHealthChecks(serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, newest?: boolean, lastOnly?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceHealthChecks(serialNumber, startDate, endDate, offset, limit, newest, lastOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the latest logs for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {number} [logType] 0&#x3D;any kind of logs (default) 0&#x3D;normal logs only 1&#x3D;crash logs only
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceLogs(serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, logType?: number, newest?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceLogs(serialNumber, startDate, endDate, offset, limit, logType, newest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the latest statistics for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [lifetime] Selecting this option means the LifetimeStatistics will be returned. All other parameters will be ignored.
         * @param {boolean} [lastOnly] Selecting this option means the LifetimeStatistics will be returned. All other parameters will be ignored.
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceStats(serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, lifetime?: boolean, lastOnly?: boolean, newest?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatisticsRecords | LifetimeStatistics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceStats(serialNumber, startDate, endDate, offset, limit, lifetime, lastOnly, newest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the latest status for a given device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceStatus(serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceStatus(serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the rtty parameters to initiate a session
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRttySessionInfo(serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RttySessionDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRttySessionInfo(serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Blink the LEDs on a device
         * @param {string} serialNumber 
         * @param {LEDsRequest} [lEDsRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ledsRequest(serialNumber: string, lEDsRequest?: LEDsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ledsRequest(serialNumber, lEDsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request a specific message
         * @param {string} serialNumber 
         * @param {MessageRequest} [messageRequest] Message request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageRequest(serialNumber: string, messageRequest?: MessageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageRequest(serialNumber, messageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upgrade a device
         * @param {string} serialNumber 
         * @param {RebootRequest} [rebootRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebootDevice(serialNumber: string, rebootRequest?: RebootRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebootDevice(serialNumber, rebootRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Launch a trace for a device
         * @param {string} serialNumber 
         * @param {TraceRequest} [traceRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async traceRequest(serialNumber: string, traceRequest?: TraceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.traceRequest(serialNumber, traceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Configura a device
         * @param {string} serialNumber 
         * @param {DeviceConfigureRequest} [deviceConfigureRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfigurationForADevice(serialNumber: string, deviceConfigureRequest?: DeviceConfigureRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConfigurationForADevice(serialNumber, deviceConfigureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upgrade a device
         * @param {string} serialNumber 
         * @param {UpgradeRequest} [upgradeRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradeDeviceFirmware(serialNumber: string, upgradeRequest?: UpgradeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradeDeviceFirmware(serialNumber, upgradeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Launch a wifi scan for a device
         * @param {string} serialNumber 
         * @param {WifiScanRequest} [wifiScanRequest] Scan details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wifiscanRequest(serialNumber: string, wifiScanRequest?: WifiScanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.wifiscanRequest(serialNumber, wifiScanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommandsApi - factory interface
 * @export
 */
export const CommandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommandsApiFp(configuration)
    return {
        /**
         * Delete a specific command
         * @summary Delete a specific command
         * @param {string} commandUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACommand(commandUUID: string, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteACommand(commandUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete some commands
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommands(serialNumber: string, startDate?: number, endDate?: number, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteCommands(serialNumber, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the capabilities for a given device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceCapabilities(serialNumber: string, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteDeviceCapabilities(serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete some device health checks
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceHealthChecks(serialNumber: string, startDate?: number, endDate?: number, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteDeviceHealthChecks(serialNumber, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete some device logs
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [logType] 0&#x3D;any kind of logs (default) 1&#x3D;normal logs only 2&#x3D;crash logs only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceLogs(serialNumber: string, startDate?: number, endDate?: number, logType?: number, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteDeviceLogs(serialNumber, startDate, endDate, logType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest statistics for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceStats(serialNumber: string, startDate?: number, endDate?: number, options?: any): AxiosPromise<Success> {
            return localVarFp.deleteDeviceStats(serialNumber, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request a list of queued events
         * @param {string} serialNumber 
         * @param {EventQueueRequest} [eventQueueRequest] Message request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventQueueRequest(serialNumber: string, eventQueueRequest?: EventQueueRequest, options?: any): AxiosPromise<void> {
            return localVarFp.eventQueueRequest(serialNumber, eventQueueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request a telemetry stream
         * @param {string} serialNumber 
         * @param {TelemetryStreamRequest} [telemetryStreamRequest] Message request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTelemetryStreamRequest(serialNumber: string, telemetryStreamRequest?: TelemetryStreamRequest, options?: any): AxiosPromise<void> {
            return localVarFp.eventTelemetryStreamRequest(serialNumber, telemetryStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post a command to a device
         * @param {string} serialNumber 
         * @param {CommandDetails} [commandDetails] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeCommand(serialNumber: string, commandDetails?: CommandDetails, options?: any): AxiosPromise<void> {
            return localVarFp.executeCommand(serialNumber, commandDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Factory reset a device a device
         * @param {string} serialNumber 
         * @param {FactoryRequest} [factoryRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        factoryReset(serialNumber: string, factoryRequest?: FactoryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.factoryReset(serialNumber, factoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific command
         * @summary Returns a specific command
         * @param {string} commandUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getACommandDetails(commandUUID: string, options?: any): AxiosPromise<CommandInfo> {
            return localVarFp.getACommandDetails(commandUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of commands.
         * @summary Returns a list of commands.
         * @param {string} [serialNumber] 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandList(serialNumber?: string, startDate?: number, endDate?: number, offset?: number, limit?: number, newest?: boolean, options?: any): AxiosPromise<CommandInfoList> {
            return localVarFp.getCommandList(serialNumber, startDate, endDate, offset, limit, newest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest capabilities for a given device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceCapabilities(serialNumber: string, options?: any): AxiosPromise<DeviceCapabilities> {
            return localVarFp.getDeviceCapabilities(serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest health checks for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {boolean} [lastOnly] Selecting this option means the last healthcheck will be returned. All other parameters will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceHealthChecks(serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, newest?: boolean, lastOnly?: boolean, options?: any): AxiosPromise<HealthCheckList> {
            return localVarFp.getDeviceHealthChecks(serialNumber, startDate, endDate, offset, limit, newest, lastOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest logs for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {number} [logType] 0&#x3D;any kind of logs (default) 0&#x3D;normal logs only 1&#x3D;crash logs only
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceLogs(serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, logType?: number, newest?: boolean, options?: any): AxiosPromise<DeviceLogList> {
            return localVarFp.getDeviceLogs(serialNumber, startDate, endDate, offset, limit, logType, newest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest statistics for a given device
         * @param {string} serialNumber 
         * @param {number} [startDate] 
         * @param {number} [endDate] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [lifetime] Selecting this option means the LifetimeStatistics will be returned. All other parameters will be ignored.
         * @param {boolean} [lastOnly] Selecting this option means the LifetimeStatistics will be returned. All other parameters will be ignored.
         * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceStats(serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, lifetime?: boolean, lastOnly?: boolean, newest?: boolean, options?: any): AxiosPromise<StatisticsRecords | LifetimeStatistics> {
            return localVarFp.getDeviceStats(serialNumber, startDate, endDate, offset, limit, lifetime, lastOnly, newest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest status for a given device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceStatus(serialNumber: string, options?: any): AxiosPromise<DeviceStatus> {
            return localVarFp.getDeviceStatus(serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the rtty parameters to initiate a session
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRttySessionInfo(serialNumber: string, options?: any): AxiosPromise<RttySessionDetails> {
            return localVarFp.getRttySessionInfo(serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Blink the LEDs on a device
         * @param {string} serialNumber 
         * @param {LEDsRequest} [lEDsRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledsRequest(serialNumber: string, lEDsRequest?: LEDsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.ledsRequest(serialNumber, lEDsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request a specific message
         * @param {string} serialNumber 
         * @param {MessageRequest} [messageRequest] Message request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageRequest(serialNumber: string, messageRequest?: MessageRequest, options?: any): AxiosPromise<void> {
            return localVarFp.messageRequest(serialNumber, messageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upgrade a device
         * @param {string} serialNumber 
         * @param {RebootRequest} [rebootRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebootDevice(serialNumber: string, rebootRequest?: RebootRequest, options?: any): AxiosPromise<void> {
            return localVarFp.rebootDevice(serialNumber, rebootRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Launch a trace for a device
         * @param {string} serialNumber 
         * @param {TraceRequest} [traceRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        traceRequest(serialNumber: string, traceRequest?: TraceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.traceRequest(serialNumber, traceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Configura a device
         * @param {string} serialNumber 
         * @param {DeviceConfigureRequest} [deviceConfigureRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigurationForADevice(serialNumber: string, deviceConfigureRequest?: DeviceConfigureRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateConfigurationForADevice(serialNumber, deviceConfigureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upgrade a device
         * @param {string} serialNumber 
         * @param {UpgradeRequest} [upgradeRequest] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeDeviceFirmware(serialNumber: string, upgradeRequest?: UpgradeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.upgradeDeviceFirmware(serialNumber, upgradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Launch a wifi scan for a device
         * @param {string} serialNumber 
         * @param {WifiScanRequest} [wifiScanRequest] Scan details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wifiscanRequest(serialNumber: string, wifiScanRequest?: WifiScanRequest, options?: any): AxiosPromise<void> {
            return localVarFp.wifiscanRequest(serialNumber, wifiScanRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommandsApi - object-oriented interface
 * @export
 * @class CommandsApi
 * @extends {BaseAPI}
 */
export class CommandsApi extends BaseAPI {
    /**
     * Delete a specific command
     * @summary Delete a specific command
     * @param {string} commandUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public deleteACommand(commandUUID: string, options?: any) {
        return CommandsApiFp(this.configuration).deleteACommand(commandUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete some commands
     * @param {string} serialNumber 
     * @param {number} [startDate] 
     * @param {number} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public deleteCommands(serialNumber: string, startDate?: number, endDate?: number, options?: any) {
        return CommandsApiFp(this.configuration).deleteCommands(serialNumber, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the capabilities for a given device
     * @param {string} serialNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public deleteDeviceCapabilities(serialNumber: string, options?: any) {
        return CommandsApiFp(this.configuration).deleteDeviceCapabilities(serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete some device health checks
     * @param {string} serialNumber 
     * @param {number} [startDate] 
     * @param {number} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public deleteDeviceHealthChecks(serialNumber: string, startDate?: number, endDate?: number, options?: any) {
        return CommandsApiFp(this.configuration).deleteDeviceHealthChecks(serialNumber, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete some device logs
     * @param {string} serialNumber 
     * @param {number} [startDate] 
     * @param {number} [endDate] 
     * @param {number} [logType] 0&#x3D;any kind of logs (default) 1&#x3D;normal logs only 2&#x3D;crash logs only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public deleteDeviceLogs(serialNumber: string, startDate?: number, endDate?: number, logType?: number, options?: any) {
        return CommandsApiFp(this.configuration).deleteDeviceLogs(serialNumber, startDate, endDate, logType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest statistics for a given device
     * @param {string} serialNumber 
     * @param {number} [startDate] 
     * @param {number} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public deleteDeviceStats(serialNumber: string, startDate?: number, endDate?: number, options?: any) {
        return CommandsApiFp(this.configuration).deleteDeviceStats(serialNumber, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request a list of queued events
     * @param {string} serialNumber 
     * @param {EventQueueRequest} [eventQueueRequest] Message request details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public eventQueueRequest(serialNumber: string, eventQueueRequest?: EventQueueRequest, options?: any) {
        return CommandsApiFp(this.configuration).eventQueueRequest(serialNumber, eventQueueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request a telemetry stream
     * @param {string} serialNumber 
     * @param {TelemetryStreamRequest} [telemetryStreamRequest] Message request details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public eventTelemetryStreamRequest(serialNumber: string, telemetryStreamRequest?: TelemetryStreamRequest, options?: any) {
        return CommandsApiFp(this.configuration).eventTelemetryStreamRequest(serialNumber, telemetryStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post a command to a device
     * @param {string} serialNumber 
     * @param {CommandDetails} [commandDetails] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public executeCommand(serialNumber: string, commandDetails?: CommandDetails, options?: any) {
        return CommandsApiFp(this.configuration).executeCommand(serialNumber, commandDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Factory reset a device a device
     * @param {string} serialNumber 
     * @param {FactoryRequest} [factoryRequest] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public factoryReset(serialNumber: string, factoryRequest?: FactoryRequest, options?: any) {
        return CommandsApiFp(this.configuration).factoryReset(serialNumber, factoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific command
     * @summary Returns a specific command
     * @param {string} commandUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getACommandDetails(commandUUID: string, options?: any) {
        return CommandsApiFp(this.configuration).getACommandDetails(commandUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of commands.
     * @summary Returns a list of commands.
     * @param {string} [serialNumber] 
     * @param {number} [startDate] 
     * @param {number} [endDate] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getCommandList(serialNumber?: string, startDate?: number, endDate?: number, offset?: number, limit?: number, newest?: boolean, options?: any) {
        return CommandsApiFp(this.configuration).getCommandList(serialNumber, startDate, endDate, offset, limit, newest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest capabilities for a given device
     * @param {string} serialNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getDeviceCapabilities(serialNumber: string, options?: any) {
        return CommandsApiFp(this.configuration).getDeviceCapabilities(serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest health checks for a given device
     * @param {string} serialNumber 
     * @param {number} [startDate] 
     * @param {number} [endDate] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
     * @param {boolean} [lastOnly] Selecting this option means the last healthcheck will be returned. All other parameters will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getDeviceHealthChecks(serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, newest?: boolean, lastOnly?: boolean, options?: any) {
        return CommandsApiFp(this.configuration).getDeviceHealthChecks(serialNumber, startDate, endDate, offset, limit, newest, lastOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest logs for a given device
     * @param {string} serialNumber 
     * @param {number} [startDate] 
     * @param {number} [endDate] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {number} [logType] 0&#x3D;any kind of logs (default) 0&#x3D;normal logs only 1&#x3D;crash logs only
     * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getDeviceLogs(serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, logType?: number, newest?: boolean, options?: any) {
        return CommandsApiFp(this.configuration).getDeviceLogs(serialNumber, startDate, endDate, offset, limit, logType, newest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest statistics for a given device
     * @param {string} serialNumber 
     * @param {number} [startDate] 
     * @param {number} [endDate] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {boolean} [lifetime] Selecting this option means the LifetimeStatistics will be returned. All other parameters will be ignored.
     * @param {boolean} [lastOnly] Selecting this option means the LifetimeStatistics will be returned. All other parameters will be ignored.
     * @param {boolean} [newest] Selecting this option means the newest record will be returned. Use limit to select how many.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getDeviceStats(serialNumber: string, startDate?: number, endDate?: number, offset?: number, limit?: number, lifetime?: boolean, lastOnly?: boolean, newest?: boolean, options?: any) {
        return CommandsApiFp(this.configuration).getDeviceStats(serialNumber, startDate, endDate, offset, limit, lifetime, lastOnly, newest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest status for a given device
     * @param {string} serialNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getDeviceStatus(serialNumber: string, options?: any) {
        return CommandsApiFp(this.configuration).getDeviceStatus(serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the rtty parameters to initiate a session
     * @param {string} serialNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getRttySessionInfo(serialNumber: string, options?: any) {
        return CommandsApiFp(this.configuration).getRttySessionInfo(serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Blink the LEDs on a device
     * @param {string} serialNumber 
     * @param {LEDsRequest} [lEDsRequest] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public ledsRequest(serialNumber: string, lEDsRequest?: LEDsRequest, options?: any) {
        return CommandsApiFp(this.configuration).ledsRequest(serialNumber, lEDsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request a specific message
     * @param {string} serialNumber 
     * @param {MessageRequest} [messageRequest] Message request details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public messageRequest(serialNumber: string, messageRequest?: MessageRequest, options?: any) {
        return CommandsApiFp(this.configuration).messageRequest(serialNumber, messageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upgrade a device
     * @param {string} serialNumber 
     * @param {RebootRequest} [rebootRequest] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public rebootDevice(serialNumber: string, rebootRequest?: RebootRequest, options?: any) {
        return CommandsApiFp(this.configuration).rebootDevice(serialNumber, rebootRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Launch a trace for a device
     * @param {string} serialNumber 
     * @param {TraceRequest} [traceRequest] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public traceRequest(serialNumber: string, traceRequest?: TraceRequest, options?: any) {
        return CommandsApiFp(this.configuration).traceRequest(serialNumber, traceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Configura a device
     * @param {string} serialNumber 
     * @param {DeviceConfigureRequest} [deviceConfigureRequest] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public updateConfigurationForADevice(serialNumber: string, deviceConfigureRequest?: DeviceConfigureRequest, options?: any) {
        return CommandsApiFp(this.configuration).updateConfigurationForADevice(serialNumber, deviceConfigureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upgrade a device
     * @param {string} serialNumber 
     * @param {UpgradeRequest} [upgradeRequest] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public upgradeDeviceFirmware(serialNumber: string, upgradeRequest?: UpgradeRequest, options?: any) {
        return CommandsApiFp(this.configuration).upgradeDeviceFirmware(serialNumber, upgradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Launch a wifi scan for a device
     * @param {string} serialNumber 
     * @param {WifiScanRequest} [wifiScanRequest] Scan details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public wifiscanRequest(serialNumber: string, wifiScanRequest?: WifiScanRequest, options?: any) {
        return CommandsApiFp(this.configuration).wifiscanRequest(serialNumber, wifiScanRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigurationsApi - axios parameter creator
 * @export
 */
export const ConfigurationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a default configuration
         * @summary Create a default configuration
         * @param {string} name 
         * @param {DefaultConfiguration} [defaultConfiguration] Information used to create the new device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultConfiguration: async (name: string, defaultConfiguration?: DefaultConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createDefaultConfiguration', 'name', name)
            const localVarPath = `/default_configuration/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(defaultConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a default default configuration
         * @summary Delete a default default configuration
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDefaultConfiguration: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteDefaultConfiguration', 'name', name)
            const localVarPath = `/default_configuration/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a default configuration
         * @summary Retrieve a default configuration
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultConfiguration: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getDefaultConfiguration', 'name', name)
            const localVarPath = `/default_configuration/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the lists of all default configurations
         * @summary Retrieve the lists of all default configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultConfigurations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/default_configurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a default configuration
         * @summary Update a default configuration
         * @param {string} name 
         * @param {DefaultConfiguration} [defaultConfiguration] Configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultConfiguration: async (name: string, defaultConfiguration?: DefaultConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateDefaultConfiguration', 'name', name)
            const localVarPath = `/default_configuration/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(defaultConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationsApi - functional programming interface
 * @export
 */
export const ConfigurationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigurationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a default configuration
         * @summary Create a default configuration
         * @param {string} name 
         * @param {DefaultConfiguration} [defaultConfiguration] Information used to create the new device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDefaultConfiguration(name: string, defaultConfiguration?: DefaultConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDefaultConfiguration(name, defaultConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a default default configuration
         * @summary Delete a default default configuration
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDefaultConfiguration(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDefaultConfiguration(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a default configuration
         * @summary Retrieve a default configuration
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultConfiguration(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultConfiguration(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the lists of all default configurations
         * @summary Retrieve the lists of all default configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultConfigurations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultConfigurationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultConfigurations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a default configuration
         * @summary Update a default configuration
         * @param {string} name 
         * @param {DefaultConfiguration} [defaultConfiguration] Configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDefaultConfiguration(name: string, defaultConfiguration?: DefaultConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDefaultConfiguration(name, defaultConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigurationsApi - factory interface
 * @export
 */
export const ConfigurationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigurationsApiFp(configuration)
    return {
        /**
         * Create a default configuration
         * @summary Create a default configuration
         * @param {string} name 
         * @param {DefaultConfiguration} [defaultConfiguration] Information used to create the new device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefaultConfiguration(name: string, defaultConfiguration?: DefaultConfiguration, options?: any): AxiosPromise<object> {
            return localVarFp.createDefaultConfiguration(name, defaultConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a default default configuration
         * @summary Delete a default default configuration
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDefaultConfiguration(name: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteDefaultConfiguration(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a default configuration
         * @summary Retrieve a default configuration
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultConfiguration(name: string, options?: any): AxiosPromise<DefaultConfiguration> {
            return localVarFp.getDefaultConfiguration(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the lists of all default configurations
         * @summary Retrieve the lists of all default configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultConfigurations(options?: any): AxiosPromise<DefaultConfigurationList> {
            return localVarFp.getDefaultConfigurations(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a default configuration
         * @summary Update a default configuration
         * @param {string} name 
         * @param {DefaultConfiguration} [defaultConfiguration] Configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultConfiguration(name: string, defaultConfiguration?: DefaultConfiguration, options?: any): AxiosPromise<object> {
            return localVarFp.updateDefaultConfiguration(name, defaultConfiguration, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigurationsApi - object-oriented interface
 * @export
 * @class ConfigurationsApi
 * @extends {BaseAPI}
 */
export class ConfigurationsApi extends BaseAPI {
    /**
     * Create a default configuration
     * @summary Create a default configuration
     * @param {string} name 
     * @param {DefaultConfiguration} [defaultConfiguration] Information used to create the new device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public createDefaultConfiguration(name: string, defaultConfiguration?: DefaultConfiguration, options?: any) {
        return ConfigurationsApiFp(this.configuration).createDefaultConfiguration(name, defaultConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a default default configuration
     * @summary Delete a default default configuration
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public deleteDefaultConfiguration(name: string, options?: any) {
        return ConfigurationsApiFp(this.configuration).deleteDefaultConfiguration(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a default configuration
     * @summary Retrieve a default configuration
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public getDefaultConfiguration(name: string, options?: any) {
        return ConfigurationsApiFp(this.configuration).getDefaultConfiguration(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the lists of all default configurations
     * @summary Retrieve the lists of all default configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public getDefaultConfigurations(options?: any) {
        return ConfigurationsApiFp(this.configuration).getDefaultConfigurations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a default configuration
     * @summary Update a default configuration
     * @param {string} name 
     * @param {DefaultConfiguration} [defaultConfiguration] Configuration details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public updateDefaultConfiguration(name: string, defaultConfiguration?: DefaultConfiguration, options?: any) {
        return ConfigurationsApiFp(this.configuration).updateDefaultConfiguration(name, defaultConfiguration, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DashboardsApi - axios parameter creator
 * @export
 */
export const DashboardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the last version of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceDashboard: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/deviceDashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the last version of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceDashboard(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceDashboard(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the last version of the dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceDashboard(options?: any): AxiosPromise<void> {
            return localVarFp.getDeviceDashboard(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
    /**
     * 
     * @summary Get the last version of the dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDeviceDashboard(options?: any) {
        return DashboardsApiFp(this.configuration).getDeviceDashboard(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creating a new device
         * @param {string} serialNumber 
         * @param {boolean} [validateOnly] 
         * @param {Device} [device] Information used to create the new device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewDevice: async (serialNumber: string, validateOnly?: boolean, device?: Device, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('createNewDevice', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (validateOnly !== undefined) {
                localVarQueryParameter['validateOnly'] = validateOnly;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleting a single device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('deleteDevice', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of device types and capabilities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCapabilitiesList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/capabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all the inforamtion about a single device
         * @summary Retrieve information for a single device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInformation: async (serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('getDeviceInformation', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of devices.
         * @summary Returns a list of devices.
         * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
         * @param {string} [filter] Filter the results
         * @param {string} [select] Supply a list of devices comma separated
         * @param {boolean} [serialOnly] only serial numbers of full device details
         * @param {boolean} [countOnly] return the number of devices
         * @param {boolean} [deviceWithStatus] Return extra information with the device information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceList: async (offset?: number, limit?: number, filter?: string, select?: string, serialOnly?: boolean, countOnly?: boolean, deviceWithStatus?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }

            if (serialOnly !== undefined) {
                localVarQueryParameter['serialOnly'] = serialOnly;
            }

            if (countOnly !== undefined) {
                localVarQueryParameter['countOnly'] = countOnly;
            }

            if (deviceWithStatus !== undefined) {
                localVarQueryParameter['deviceWithStatus'] = deviceWithStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updating a new device
         * @param {string} serialNumber 
         * @param {Device} [device] Information used to create the new device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNewDevice: async (serialNumber: string, device?: Device, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('updateNewDevice', 'serialNumber', serialNumber)
            const localVarPath = `/device/{serialNumber}`
                .replace(`{${"serialNumber"}}`, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creating a new device
         * @param {string} serialNumber 
         * @param {boolean} [validateOnly] 
         * @param {Device} [device] Information used to create the new device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewDevice(serialNumber: string, validateOnly?: boolean, device?: Device, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewDevice(serialNumber, validateOnly, device, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deleting a single device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of device types and capabilities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCapabilitiesList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CapabilitiesModelList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCapabilitiesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all the inforamtion about a single device
         * @summary Retrieve information for a single device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceInformation(serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceInformation(serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of devices.
         * @summary Returns a list of devices.
         * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
         * @param {string} [filter] Filter the results
         * @param {string} [select] Supply a list of devices comma separated
         * @param {boolean} [serialOnly] only serial numbers of full device details
         * @param {boolean} [countOnly] return the number of devices
         * @param {boolean} [deviceWithStatus] Return extra information with the device information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceList(offset?: number, limit?: number, filter?: string, select?: string, serialOnly?: boolean, countOnly?: boolean, deviceWithStatus?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceList | DeviceListWithStatus | SerialNumberList | DeviceCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceList(offset, limit, filter, select, serialOnly, countOnly, deviceWithStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updating a new device
         * @param {string} serialNumber 
         * @param {Device} [device] Information used to create the new device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNewDevice(serialNumber: string, device?: Device, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNewDevice(serialNumber, device, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Creating a new device
         * @param {string} serialNumber 
         * @param {boolean} [validateOnly] 
         * @param {Device} [device] Information used to create the new device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewDevice(serialNumber: string, validateOnly?: boolean, device?: Device, options?: any): AxiosPromise<Device> {
            return localVarFp.createNewDevice(serialNumber, validateOnly, device, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleting a single device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(serialNumber: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteDevice(serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of device types and capabilities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCapabilitiesList(options?: any): AxiosPromise<CapabilitiesModelList> {
            return localVarFp.getCapabilitiesList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all the inforamtion about a single device
         * @summary Retrieve information for a single device
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInformation(serialNumber: string, options?: any): AxiosPromise<Device> {
            return localVarFp.getDeviceInformation(serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of devices.
         * @summary Returns a list of devices.
         * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
         * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
         * @param {string} [filter] Filter the results
         * @param {string} [select] Supply a list of devices comma separated
         * @param {boolean} [serialOnly] only serial numbers of full device details
         * @param {boolean} [countOnly] return the number of devices
         * @param {boolean} [deviceWithStatus] Return extra information with the device information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceList(offset?: number, limit?: number, filter?: string, select?: string, serialOnly?: boolean, countOnly?: boolean, deviceWithStatus?: boolean, options?: any): AxiosPromise<DeviceList | DeviceListWithStatus | SerialNumberList | DeviceCount> {
            return localVarFp.getDeviceList(offset, limit, filter, select, serialOnly, countOnly, deviceWithStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updating a new device
         * @param {string} serialNumber 
         * @param {Device} [device] Information used to create the new device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNewDevice(serialNumber: string, device?: Device, options?: any): AxiosPromise<Device> {
            return localVarFp.updateNewDevice(serialNumber, device, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * 
     * @summary Creating a new device
     * @param {string} serialNumber 
     * @param {boolean} [validateOnly] 
     * @param {Device} [device] Information used to create the new device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public createNewDevice(serialNumber: string, validateOnly?: boolean, device?: Device, options?: any) {
        return DevicesApiFp(this.configuration).createNewDevice(serialNumber, validateOnly, device, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleting a single device
     * @param {string} serialNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDevice(serialNumber: string, options?: any) {
        return DevicesApiFp(this.configuration).deleteDevice(serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of device types and capabilities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getCapabilitiesList(options?: any) {
        return DevicesApiFp(this.configuration).getCapabilitiesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all the inforamtion about a single device
     * @summary Retrieve information for a single device
     * @param {string} serialNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceInformation(serialNumber: string, options?: any) {
        return DevicesApiFp(this.configuration).getDeviceInformation(serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of devices.
     * @summary Returns a list of devices.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [serialOnly] only serial numbers of full device details
     * @param {boolean} [countOnly] return the number of devices
     * @param {boolean} [deviceWithStatus] Return extra information with the device information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceList(offset?: number, limit?: number, filter?: string, select?: string, serialOnly?: boolean, countOnly?: boolean, deviceWithStatus?: boolean, options?: any) {
        return DevicesApiFp(this.configuration).getDeviceList(offset, limit, filter, select, serialOnly, countOnly, deviceWithStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updating a new device
     * @param {string} serialNumber 
     * @param {Device} [device] Information used to create the new device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateNewDevice(serialNumber: string, device?: Device, options?: any) {
        return DevicesApiFp(this.configuration).updateNewDevice(serialNumber, device, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a file from the upload directory
         * @param {string} uuid 
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadFidelete: async (uuid: string, serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteUploadFidelete', 'uuid', uuid)
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('deleteUploadFidelete', 'serialNumber', serialNumber)
            const localVarPath = `/file/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (serialNumber !== undefined) {
                localVarQueryParameter['serialNumber'] = serialNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file from the upload directory
         * @param {string} uuid 
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadFile: async (uuid: string, serialNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getUploadFile', 'uuid', uuid)
            // verify required parameter 'serialNumber' is not null or undefined
            assertParamExists('getUploadFile', 'serialNumber', serialNumber)
            const localVarPath = `/file/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (serialNumber !== undefined) {
                localVarQueryParameter['serialNumber'] = serialNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a file from the upload directory
         * @param {string} uuid 
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUploadFidelete(uuid: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUploadFidelete(uuid, serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a file from the upload directory
         * @param {string} uuid 
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadFile(uuid: string, serialNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUploadFile(uuid, serialNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a file from the upload directory
         * @param {string} uuid 
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadFidelete(uuid: string, serialNumber: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteUploadFidelete(uuid, serialNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file from the upload directory
         * @param {string} uuid 
         * @param {string} serialNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadFile(uuid: string, serialNumber: string, options?: any): AxiosPromise<any> {
            return localVarFp.getUploadFile(uuid, serialNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a file from the upload directory
     * @param {string} uuid 
     * @param {string} serialNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteUploadFidelete(uuid: string, serialNumber: string, options?: any) {
        return FilesApiFp(this.configuration).deleteUploadFidelete(uuid, serialNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a file from the upload directory
     * @param {string} uuid 
     * @param {string} serialNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getUploadFile(uuid: string, serialNumber: string, options?: any) {
        return FilesApiFp(this.configuration).getUploadFile(uuid, serialNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OUIsApi - axios parameter creator
 * @export
 */
export const OUIsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of OUIs
         * @param {string} macList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOUIs: async (macList: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'macList' is not null or undefined
            assertParamExists('getOUIs', 'macList', macList)
            const localVarPath = `/ouis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (macList !== undefined) {
                localVarQueryParameter['macList'] = macList;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OUIsApi - functional programming interface
 * @export
 */
export const OUIsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OUIsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of OUIs
         * @param {string} macList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOUIs(macList: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOUIs(macList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OUIsApi - factory interface
 * @export
 */
export const OUIsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OUIsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of OUIs
         * @param {string} macList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOUIs(macList: string, options?: any): AxiosPromise<void> {
            return localVarFp.getOUIs(macList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OUIsApi - object-oriented interface
 * @export
 * @class OUIsApi
 * @extends {BaseAPI}
 */
export class OUIsApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of OUIs
     * @param {string} macList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OUIsApi
     */
    public getOUIs(macList: string, options?: any) {
        return OUIsApiFp(this.configuration).getOUIs(macList, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemCommandsApi - axios parameter creator
 * @export
 */
export const SystemCommandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve different values from the running service.
         * @param {'info'} command Get a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCommand: async (command: 'info', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'command' is not null or undefined
            assertParamExists('getSystemCommand', 'command', command)
            const localVarPath = `/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (command !== undefined) {
                localVarQueryParameter['command'] = command;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform some systeme wide commands
         * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemCommand: async (systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?: SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemCommandsApi - functional programming interface
 * @export
 */
export const SystemCommandsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemCommandsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve different values from the running service.
         * @param {'info'} command Get a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemCommand(command: 'info', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfoResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemCommand(command, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Perform some systeme wide commands
         * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemCommand(systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?: SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemGetLogLevelsResult | SystemCommandGetLogLevelNamesResult | SystemGetSubSystemNamesResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemCommand(systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemCommandsApi - factory interface
 * @export
 */
export const SystemCommandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemCommandsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve different values from the running service.
         * @param {'info'} command Get a value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemCommand(command: 'info', options?: any): AxiosPromise<SystemInfoResults> {
            return localVarFp.getSystemCommand(command, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform some systeme wide commands
         * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemCommand(systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?: SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames, options?: any): AxiosPromise<SystemGetLogLevelsResult | SystemCommandGetLogLevelNamesResult | SystemGetSubSystemNamesResult> {
            return localVarFp.systemCommand(systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemCommandsApi - object-oriented interface
 * @export
 * @class SystemCommandsApi
 * @extends {BaseAPI}
 */
export class SystemCommandsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve different values from the running service.
     * @param {'info'} command Get a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemCommandsApi
     */
    public getSystemCommand(command: 'info', options?: any) {
        return SystemCommandsApiFp(this.configuration).getSystemCommand(command, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform some systeme wide commands
     * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemCommandsApi
     */
    public systemCommand(systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?: SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames, options?: any) {
        return SystemCommandsApiFp(this.configuration).systemCommand(systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames, options).then((request) => request(this.axios, this.basePath));
    }
}


