/* tslint:disable */
/* eslint-disable */
/**
 * OpenWiFi Provisioning Model
 * Definitions and APIs to manages an OpenWiFi network.
 *
 * The version of the OpenAPI document: 2.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AnyPayload
 */
export interface AnyPayload {
  /**
   *
   * @type {string}
   * @memberof AnyPayload
   */
  Document?: string;
}
/**
 *
 * @export
 * @interface Contact
 */
export interface Contact {
  /**
   *
   * @type {ObjectInfo}
   * @memberof Contact
   */
  allOf?: ObjectInfo;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  type?: ContactTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  salutation?: string;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  firstname?: string;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  lastname?: string;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  initials?: string;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  visual?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Contact
   */
  phones?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Contact
   */
  mobiles?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  primaryEmail?: string;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  secondaryEmail?: string;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  accessPIN?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Contact
   */
  inUse?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  entity?: string;
  /**
   *
   * @type {string}
   * @memberof Contact
   */
  managementPolicy?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ContactTypeEnum {
  Subscriber = 'SUBSCRIBER',
  User = 'USER',
  Installer = 'INSTALLER',
  Csr = 'CSR',
  Manager = 'MANAGER',
  Businessowner = 'BUSINESSOWNER',
  Technician = 'TECHNICIAN',
  Corporate = 'CORPORATE',
}

/**
 *
 * @export
 * @interface ContactList
 */
export interface ContactList {
  /**
   *
   * @type {Array<Contact>}
   * @memberof ContactList
   */
  contacts?: Array<Contact>;
}
/**
 *
 * @export
 * @interface CountAnswer
 */
export interface CountAnswer {
  /**
   *
   * @type {number}
   * @memberof CountAnswer
   */
  count?: number;
}
/**
 *
 * @export
 * @interface Dashboard
 */
export interface Dashboard {
  /**
   *
   * @type {number}
   * @memberof Dashboard
   */
  snapshot?: number;
  /**
   *
   * @type {TagIntPairList}
   * @memberof Dashboard
   */
  tenants?: TagIntPairList;
}
/**
 *
 * @export
 * @interface DeviceConfiguration
 */
export interface DeviceConfiguration {
  /**
   *
   * @type {ObjectInfo}
   * @memberof DeviceConfiguration
   */
  allOf?: ObjectInfo;
  /**
   *
   * @type {string}
   * @memberof DeviceConfiguration
   */
  managementPolicy?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DeviceConfiguration
   */
  deviceTypes?: Array<string>;
  /**
   *
   * @type {Array<DeviceConfigurationElement>}
   * @memberof DeviceConfiguration
   */
  configuration?: Array<DeviceConfigurationElement>;
  /**
   *
   * @type {Array<TagValuePairList>}
   * @memberof DeviceConfiguration
   */
  variables?: Array<TagValuePairList>;
  /**
   *
   * @type {Array<string>}
   * @memberof DeviceConfiguration
   */
  inUse?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof DeviceConfiguration
   */
  rrm?: DeviceConfigurationRrmEnum;
  /**
   *
   * @type {string}
   * @memberof DeviceConfiguration
   */
  firmwareUpgrade?: string;
  /**
   *
   * @type {boolean}
   * @memberof DeviceConfiguration
   */
  firmwareRCOnly?: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum DeviceConfigurationRrmEnum {
  False = 'false',
  True = 'true',
  Inherit = 'inherit',
}

/**
 *
 * @export
 * @interface DeviceConfigurationElement
 */
export interface DeviceConfigurationElement {
  /**
   *
   * @type {string}
   * @memberof DeviceConfigurationElement
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof DeviceConfigurationElement
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof DeviceConfigurationElement
   */
  weight?: number;
  /**
   *
   * @type {string}
   * @memberof DeviceConfigurationElement
   */
  configuration?: string;
}
/**
 *
 * @export
 * @interface DeviceConfigurationList
 */
export interface DeviceConfigurationList {
  /**
   *
   * @type {Array<DeviceConfiguration>}
   * @memberof DeviceConfigurationList
   */
  configurations?: Array<DeviceConfiguration>;
}
/**
 *
 * @export
 * @interface DiGraphEntry
 */
export interface DiGraphEntry {
  /**
   *
   * @type {string}
   * @memberof DiGraphEntry
   */
  parent?: string;
  /**
   *
   * @type {string}
   * @memberof DiGraphEntry
   */
  child?: string;
}
/**
 *
 * @export
 * @interface Entity
 */
export interface Entity {
  /**
   *
   * @type {ObjectInfo}
   * @memberof Entity
   */
  allOf?: ObjectInfo;
  /**
   * If empty, then this is the root entity, otherwise this points to a parent entity
   * @type {string}
   * @memberof Entity
   */
  parent?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Entity
   */
  children?: Array<string>;
  /**
   * The list of UUID of the venues for this entity
   * @type {Array<string>}
   * @memberof Entity
   */
  venues?: Array<string>;
  /**
   * The list of UUID of the contacts for the entity
   * @type {Array<string>}
   * @memberof Entity
   */
  contacts?: Array<string>;
  /**
   * The list of UUID of the locations associated with thit entiry
   * @type {Array<string>}
   * @memberof Entity
   */
  locations?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Entity
   */
  managementPolicy?: string;
  /**
   *
   * @type {string}
   * @memberof Entity
   */
  deviceConfiguration?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Entity
   */
  devices?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Entity
   */
  rrm?: EntityRrmEnum;
  /**
   *
   * @type {StringList}
   * @memberof Entity
   */
  sourceIP?: StringList;
}

/**
 * @export
 * @enum {string}
 */
export enum EntityRrmEnum {
  False = 'false',
  True = 'true',
  Inherit = 'inherit',
}

/**
 *
 * @export
 * @interface EntityList
 */
export interface EntityList {
  /**
   *
   * @type {Array<Entity>}
   * @memberof EntityList
   */
  entities?: Array<Entity>;
}
/**
 *
 * @export
 * @interface ExpandedUseEntry
 */
export interface ExpandedUseEntry {
  /**
   *
   * @type {string}
   * @memberof ExpandedUseEntry
   */
  uuid?: string;
  /**
   *
   * @type {string}
   * @memberof ExpandedUseEntry
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ExpandedUseEntry
   */
  description?: string;
}
/**
 *
 * @export
 * @interface ExpandedUseEntryMap
 */
export interface ExpandedUseEntryMap {
  /**
   *
   * @type {string}
   * @memberof ExpandedUseEntryMap
   */
  type?: string;
  /**
   *
   * @type {Array<ExpandedUseEntry>}
   * @memberof ExpandedUseEntryMap
   */
  entries?: Array<ExpandedUseEntry>;
}
/**
 *
 * @export
 * @interface ExpandedUseEntryMapList
 */
export interface ExpandedUseEntryMapList {
  /**
   *
   * @type {Array<ExpandedUseEntryMap>}
   * @memberof ExpandedUseEntryMapList
   */
  entries?: Array<ExpandedUseEntryMap>;
}
/**
 *
 * @export
 * @interface FirmwareOptions
 */
export interface FirmwareOptions {
  /**
   *
   * @type {string}
   * @memberof FirmwareOptions
   */
  firmwareUpgrade?: string;
  /**
   *
   * @type {boolean}
   * @memberof FirmwareOptions
   */
  firmwareRCOnly?: boolean;
  /**
   *
   * @type {string}
   * @memberof FirmwareOptions
   */
  from?: string;
}
/**
 *
 * @export
 * @interface InventoryConfigApplyResult
 */
export interface InventoryConfigApplyResult {
  /**
   *
   * @type {string}
   * @memberof InventoryConfigApplyResult
   */
  appliedConfiguration?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InventoryConfigApplyResult
   */
  errors?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof InventoryConfigApplyResult
   */
  warnings?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof InventoryConfigApplyResult
   */
  errorCode?: number;
}
/**
 *
 * @export
 * @interface InventoryTag
 */
export interface InventoryTag {
  /**
   *
   * @type {ObjectInfo}
   * @memberof InventoryTag
   */
  allOf?: ObjectInfo;
  /**
   *
   * @type {string}
   * @memberof InventoryTag
   */
  serialNumber?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryTag
   */
  deviceType?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryTag
   */
  venue?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryTag
   */
  entity?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryTag
   */
  qrCode?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryTag
   */
  geoCode?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryTag
   */
  location?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryTag
   */
  contact?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryTag
   */
  deviceConfiguration?: string;
  /**
   *
   * @type {string}
   * @memberof InventoryTag
   */
  rrm?: InventoryTagRrmEnum;
  /**
   *
   * @type {string}
   * @memberof InventoryTag
   */
  managementPolicy?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum InventoryTagRrmEnum {
  False = 'false',
  True = 'true',
  Inherit = 'inherit',
}

/**
 *
 * @export
 * @interface InventoryTagList
 */
export interface InventoryTagList {
  /**
   *
   * @type {Array<InventoryTag>}
   * @memberof InventoryTagList
   */
  taglist?: Array<InventoryTag>;
}
/**
 *
 * @export
 * @interface Location
 */
export interface Location {
  /**
   *
   * @type {ObjectInfo}
   * @memberof Location
   */
  allOf?: ObjectInfo;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  type?: LocationTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  buildingName?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Location
   */
  addressLines?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  postal?: string;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  country?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Location
   */
  phones?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Location
   */
  mobiles?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Location
   */
  inUse?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  entity?: string;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  managementPolicy?: string;
  /**
   *
   * @type {string}
   * @memberof Location
   */
  geoCode?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum LocationTypeEnum {
  Service = 'SERVICE',
  Equipment = 'EQUIPMENT',
  Auto = 'AUTO',
  Manual = 'MANUAL',
  Special = 'SPECIAL',
  Unknown = 'UNKNOWN',
  Corporate = 'CORPORATE',
}

/**
 *
 * @export
 * @interface LocationList
 */
export interface LocationList {
  /**
   *
   * @type {Array<Location>}
   * @memberof LocationList
   */
  locations?: Array<Location>;
}
/**
 *
 * @export
 * @interface ManagementPolicy
 */
export interface ManagementPolicy {
  /**
   *
   * @type {ObjectInfo}
   * @memberof ManagementPolicy
   */
  allOf?: ObjectInfo;
  /**
   *
   * @type {Array<ManagementPolicyEntry>}
   * @memberof ManagementPolicy
   */
  entries?: Array<ManagementPolicyEntry>;
  /**
   *
   * @type {Array<string>}
   * @memberof ManagementPolicy
   */
  inUse?: Array<string>;
}
/**
 *
 * @export
 * @interface ManagementPolicyEntry
 */
export interface ManagementPolicyEntry {
  /**
   *
   * @type {Array<string>}
   * @memberof ManagementPolicyEntry
   */
  users?: Array<string>;
  /**
   * this is a list of UUID and UUID Patterns to control by this policy
   * @type {Array<string>}
   * @memberof ManagementPolicyEntry
   */
  resources?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ManagementPolicyEntry
   */
  access?: Array<ManagementPolicyEntryAccessEnum>;
  /**
   * A JSON document describing the policy
   * @type {string}
   * @memberof ManagementPolicyEntry
   */
  policy?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ManagementPolicyEntryAccessEnum {
  Noaccess = 'NOACCESS',
  Read = 'READ',
  Modify = 'MODIFY',
  Delete = 'DELETE',
  List = 'LIST',
  Create = 'CREATE',
  Full = 'FULL',
}

/**
 *
 * @export
 * @interface ManagementPolicyList
 */
export interface ManagementPolicyList {
  /**
   *
   * @type {Array<ManagementPolicy>}
   * @memberof ManagementPolicyList
   */
  policies?: Array<ManagementPolicy>;
}
/**
 *
 * @export
 * @interface ManagementRole
 */
export interface ManagementRole {
  /**
   *
   * @type {ObjectInfo}
   * @memberof ManagementRole
   */
  allOf?: ObjectInfo;
  /**
   *
   * @type {string}
   * @memberof ManagementRole
   */
  managementPolicy?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ManagementRole
   */
  users?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ManagementRole
   */
  inUse?: Array<string>;
}
/**
 *
 * @export
 * @interface ManagementRoleList
 */
export interface ManagementRoleList {
  /**
   *
   * @type {Array<ManagementRole>}
   * @memberof ManagementRoleList
   */
  roles?: Array<ManagementRole>;
}
/**
 *
 * @export
 * @interface NoteInfo
 */
export interface NoteInfo {
  /**
   *
   * @type {number}
   * @memberof NoteInfo
   */
  created?: number;
  /**
   *
   * @type {string}
   * @memberof NoteInfo
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof NoteInfo
   */
  note?: string;
}
/**
 *
 * @export
 * @interface ObjectInfo
 */
export interface ObjectInfo {
  /**
   *
   * @type {string}
   * @memberof ObjectInfo
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ObjectInfo
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ObjectInfo
   */
  description?: string;
  /**
   *
   * @type {Array<NoteInfo>}
   * @memberof ObjectInfo
   */
  notes?: Array<NoteInfo>;
  /**
   *
   * @type {number}
   * @memberof ObjectInfo
   */
  created?: number;
  /**
   *
   * @type {number}
   * @memberof ObjectInfo
   */
  modified?: number;
  /**
   *
   * @type {Array<number>}
   * @memberof ObjectInfo
   */
  tags?: Array<number>;
}
/**
 *
 * @export
 * @interface SerialNumberList
 */
export interface SerialNumberList {
  /**
   *
   * @type {Array<string>}
   * @memberof SerialNumberList
   */
  serialNumbers?: Array<string>;
}
/**
 *
 * @export
 * @interface StringList
 */
export interface StringList {
  /**
   *
   * @type {Array<string>}
   * @memberof StringList
   */
  list?: Array<string>;
}
/**
 *
 * @export
 * @interface SystemCommandDetails
 */
export interface SystemCommandDetails {
  /**
   *
   * @type {string}
   * @memberof SystemCommandDetails
   */
  command?: SystemCommandDetailsCommandEnum;
  /**
   *
   * @type {StringList | TagValuePairList}
   * @memberof SystemCommandDetails
   */
  parameters?: StringList | TagValuePairList;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandDetailsCommandEnum {
  Setloglevels = 'setloglevels',
  Getloglevels = 'getloglevels',
  GetSubSystemNames = 'getSubSystemNames',
  GetLogLevelNames = 'getLogLevelNames',
  Stats = 'stats',
}

/**
 *
 * @export
 * @interface SystemCommandGetLogLevelNames
 */
export interface SystemCommandGetLogLevelNames {
  /**
   *
   * @type {string}
   * @memberof SystemCommandGetLogLevelNames
   */
  command?: SystemCommandGetLogLevelNamesCommandEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandGetLogLevelNamesCommandEnum {
  Getloglevelnames = 'getloglevelnames',
}

/**
 *
 * @export
 * @interface SystemCommandGetLogLevelNamesResult
 */
export interface SystemCommandGetLogLevelNamesResult {
  /**
   *
   * @type {Array<string>}
   * @memberof SystemCommandGetLogLevelNamesResult
   */
  list?: Array<string>;
}
/**
 *
 * @export
 * @interface SystemCommandGetLogLevels
 */
export interface SystemCommandGetLogLevels {
  /**
   *
   * @type {string}
   * @memberof SystemCommandGetLogLevels
   */
  command?: SystemCommandGetLogLevelsCommandEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandGetLogLevelsCommandEnum {
  Getloglevels = 'getloglevels',
}

/**
 *
 * @export
 * @interface SystemCommandGetSubsystemNames
 */
export interface SystemCommandGetSubsystemNames {
  /**
   *
   * @type {string}
   * @memberof SystemCommandGetSubsystemNames
   */
  command?: SystemCommandGetSubsystemNamesCommandEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandGetSubsystemNamesCommandEnum {
  Getsubsystemnames = 'getsubsystemnames',
}

/**
 *
 * @export
 * @interface SystemCommandReload
 */
export interface SystemCommandReload {
  /**
   *
   * @type {string}
   * @memberof SystemCommandReload
   */
  command?: SystemCommandReloadCommandEnum;
  /**
   *
   * @type {Array<string>}
   * @memberof SystemCommandReload
   */
  subsystems?: Array<string>;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandReloadCommandEnum {
  Reload = 'reload',
}

/**
 * @type SystemCommandResults
 * @export
 */
export type SystemCommandResults = StringList | TagValuePairList;

/**
 *
 * @export
 * @interface SystemCommandSetLogLevel
 */
export interface SystemCommandSetLogLevel {
  /**
   *
   * @type {string}
   * @memberof SystemCommandSetLogLevel
   */
  command?: SystemCommandSetLogLevelCommandEnum;
  /**
   *
   * @type {Array<TagValuePair>}
   * @memberof SystemCommandSetLogLevel
   */
  subsystems?: Array<TagValuePair>;
}

/**
 * @export
 * @enum {string}
 */
export enum SystemCommandSetLogLevelCommandEnum {
  Setloglevel = 'setloglevel',
}

/**
 *
 * @export
 * @interface SystemGetLogLevelsResult
 */
export interface SystemGetLogLevelsResult {
  /**
   *
   * @type {Array<TagValuePair>}
   * @memberof SystemGetLogLevelsResult
   */
  taglist?: Array<TagValuePair>;
}
/**
 *
 * @export
 * @interface SystemGetSubSystemNamesResult
 */
export interface SystemGetSubSystemNamesResult {
  /**
   *
   * @type {Array<TagValuePair>}
   * @memberof SystemGetSubSystemNamesResult
   */
  taglist?: Array<TagValuePair>;
}
/**
 *
 * @export
 * @interface SystemInfoResults
 */
export interface SystemInfoResults {
  /**
   *
   * @type {string}
   * @memberof SystemInfoResults
   */
  version?: string;
  /**
   *
   * @type {number}
   * @memberof SystemInfoResults
   */
  uptime?: number;
  /**
   *
   * @type {number}
   * @memberof SystemInfoResults
   */
  start?: number;
  /**
   *
   * @type {string}
   * @memberof SystemInfoResults
   */
  os?: string;
  /**
   *
   * @type {number}
   * @memberof SystemInfoResults
   */
  processors?: number;
  /**
   *
   * @type {string}
   * @memberof SystemInfoResults
   */
  hostname?: string;
  /**
   *
   * @type {Array<SystemInfoResultsCertificates>}
   * @memberof SystemInfoResults
   */
  certificates?: Array<SystemInfoResultsCertificates>;
}
/**
 *
 * @export
 * @interface SystemInfoResultsCertificates
 */
export interface SystemInfoResultsCertificates {
  /**
   *
   * @type {string}
   * @memberof SystemInfoResultsCertificates
   */
  filename?: string;
  /**
   *
   * @type {number}
   * @memberof SystemInfoResultsCertificates
   */
  expires?: number;
}
/**
 *
 * @export
 * @interface TagIntPair
 */
export interface TagIntPair {
  /**
   *
   * @type {string}
   * @memberof TagIntPair
   */
  tag?: string;
  /**
   *
   * @type {number}
   * @memberof TagIntPair
   */
  value?: number;
}
/**
 *
 * @export
 * @interface TagIntPairList
 */
export interface TagIntPairList {
  /**
   *
   * @type {Array<TagIntPair>}
   * @memberof TagIntPairList
   */
  tagList?: Array<TagIntPair>;
}
/**
 *
 * @export
 * @interface TagValuePair
 */
export interface TagValuePair {
  /**
   *
   * @type {string}
   * @memberof TagValuePair
   */
  tag?: string;
  /**
   *
   * @type {string}
   * @memberof TagValuePair
   */
  value?: string;
}
/**
 *
 * @export
 * @interface TagValuePairList
 */
export interface TagValuePairList {
  /**
   *
   * @type {Array<TagValuePair>}
   * @memberof TagValuePairList
   */
  tagList?: Array<TagValuePair>;
}
/**
 *
 * @export
 * @interface UserInfoDigest
 */
export interface UserInfoDigest {
  /**
   *
   * @type {string}
   * @memberof UserInfoDigest
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfoDigest
   */
  loginId?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfoDigest
   */
  type?: string;
}
/**
 *
 * @export
 * @interface Venue
 */
export interface Venue {
  /**
   *
   * @type {ObjectInfo}
   * @memberof Venue
   */
  allOf?: ObjectInfo;
  /**
   *
   * @type {string}
   * @memberof Venue
   */
  entity?: string;
  /**
   *
   * @type {string}
   * @memberof Venue
   */
  parent?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Venue
   */
  children?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Venue
   */
  managementPolicy?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Venue
   */
  devices?: Array<string>;
  /**
   *
   * @type {Array<DiGraphEntry>}
   * @memberof Venue
   */
  topology?: Array<DiGraphEntry>;
  /**
   *
   * @type {string}
   * @memberof Venue
   */
  design?: string;
  /**
   *
   * @type {string}
   * @memberof Venue
   */
  deviceConfiguration?: string;
  /**
   *
   * @type {string}
   * @memberof Venue
   */
  contact?: string;
  /**
   *
   * @type {string}
   * @memberof Venue
   */
  location?: string;
  /**
   *
   * @type {string}
   * @memberof Venue
   */
  rrm?: VenueRrmEnum;
  /**
   *
   * @type {StringList}
   * @memberof Venue
   */
  sourceIP?: StringList;
}

/**
 * @export
 * @enum {string}
 */
export enum VenueRrmEnum {
  False = 'false',
  True = 'true',
  Inherit = 'inherit',
}

/**
 *
 * @export
 * @interface VenueList
 */
export interface VenueList {
  /**
   *
   * @type {Array<Venue>}
   * @memberof VenueList
   */
  venues?: Array<Venue>;
}

/**
 * ConfigurationsApi - axios parameter creator
 * @export
 */
export const ConfigurationsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a specific configuration.
     * @param {string} uuid
     * @param {boolean} [validateOnly]
     * @param {DeviceConfiguration} [deviceConfiguration] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConfiguration: async (
      uuid: string,
      validateOnly?: boolean,
      deviceConfiguration?: DeviceConfiguration,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('createConfiguration', 'uuid', uuid);
      const localVarPath = `/configurations/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (validateOnly !== undefined) {
        localVarQueryParameter['validateOnly'] = validateOnly;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(deviceConfiguration, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a specific configuration.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConfiguration: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('deleteConfiguration', 'uuid', uuid);
      const localVarPath = `/configurations/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a specific configuration.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    geConfiguration: async (uuid: string, expandInUse?: boolean, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('geConfiguration', 'uuid', uuid);
      const localVarPath = `/configurations/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (expandInUse !== undefined) {
        localVarQueryParameter['expandInUse'] = expandInUse;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a list of configurations.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [countOnly] return the number of devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfigurations: async (
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/configurations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select;
      }

      if (countOnly !== undefined) {
        localVarQueryParameter['countOnly'] = countOnly;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Modify a specific configuration.
     * @param {string} uuid
     * @param {DeviceConfiguration} [deviceConfiguration] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyConfiguration: async (
      uuid: string,
      deviceConfiguration?: DeviceConfiguration,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modifyConfiguration', 'uuid', uuid);
      const localVarPath = `/configurations/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(deviceConfiguration, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConfigurationsApi - functional programming interface
 * @export
 */
export const ConfigurationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ConfigurationsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a specific configuration.
     * @param {string} uuid
     * @param {boolean} [validateOnly]
     * @param {DeviceConfiguration} [deviceConfiguration] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createConfiguration(
      uuid: string,
      validateOnly?: boolean,
      deviceConfiguration?: DeviceConfiguration,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createConfiguration(
        uuid,
        validateOnly,
        deviceConfiguration,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete a specific configuration.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteConfiguration(
      uuid: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConfiguration(uuid, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a specific configuration.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async geConfiguration(
      uuid: string,
      expandInUse?: boolean,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceConfiguration | ExpandedUseEntryMapList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.geConfiguration(uuid, expandInUse, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a list of configurations.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [countOnly] return the number of devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConfigurations(
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceConfigurationList | CountAnswer>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigurations(
        offset,
        limit,
        filter,
        select,
        countOnly,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Modify a specific configuration.
     * @param {string} uuid
     * @param {DeviceConfiguration} [deviceConfiguration] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modifyConfiguration(
      uuid: string,
      deviceConfiguration?: DeviceConfiguration,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modifyConfiguration(uuid, deviceConfiguration, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ConfigurationsApi - factory interface
 * @export
 */
export const ConfigurationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ConfigurationsApiFp(configuration);
  return {
    /**
     *
     * @summary Create a specific configuration.
     * @param {string} uuid
     * @param {boolean} [validateOnly]
     * @param {DeviceConfiguration} [deviceConfiguration] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConfiguration(
      uuid: string,
      validateOnly?: boolean,
      deviceConfiguration?: DeviceConfiguration,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .createConfiguration(uuid, validateOnly, deviceConfiguration, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a specific configuration.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConfiguration(uuid: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteConfiguration(uuid, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a specific configuration.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    geConfiguration(
      uuid: string,
      expandInUse?: boolean,
      options?: any,
    ): AxiosPromise<DeviceConfiguration | ExpandedUseEntryMapList> {
      return localVarFp.geConfiguration(uuid, expandInUse, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a list of configurations.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [countOnly] return the number of devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfigurations(
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options?: any,
    ): AxiosPromise<DeviceConfigurationList | CountAnswer> {
      return localVarFp
        .getConfigurations(offset, limit, filter, select, countOnly, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Modify a specific configuration.
     * @param {string} uuid
     * @param {DeviceConfiguration} [deviceConfiguration] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyConfiguration(uuid: string, deviceConfiguration?: DeviceConfiguration, options?: any): AxiosPromise<void> {
      return localVarFp
        .modifyConfiguration(uuid, deviceConfiguration, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ConfigurationsApi - object-oriented interface
 * @export
 * @class ConfigurationsApi
 * @extends {BaseAPI}
 */
export class ConfigurationsApi extends BaseAPI {
  /**
   *
   * @summary Create a specific configuration.
   * @param {string} uuid
   * @param {boolean} [validateOnly]
   * @param {DeviceConfiguration} [deviceConfiguration] Information used to create the new entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationsApi
   */
  public createConfiguration(
    uuid: string,
    validateOnly?: boolean,
    deviceConfiguration?: DeviceConfiguration,
    options?: any,
  ) {
    return ConfigurationsApiFp(this.configuration)
      .createConfiguration(uuid, validateOnly, deviceConfiguration, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a specific configuration.
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationsApi
   */
  public deleteConfiguration(uuid: string, options?: any) {
    return ConfigurationsApiFp(this.configuration)
      .deleteConfiguration(uuid, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a specific configuration.
   * @param {string} uuid
   * @param {boolean} [expandInUse]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationsApi
   */
  public geConfiguration(uuid: string, expandInUse?: boolean, options?: any) {
    return ConfigurationsApiFp(this.configuration)
      .geConfiguration(uuid, expandInUse, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a list of configurations.
   * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
   * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
   * @param {string} [filter] Filter the results
   * @param {string} [select] Supply a list of devices comma separated
   * @param {boolean} [countOnly] return the number of devices
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationsApi
   */
  public getConfigurations(
    offset?: number,
    limit?: number,
    filter?: string,
    select?: string,
    countOnly?: boolean,
    options?: any,
  ) {
    return ConfigurationsApiFp(this.configuration)
      .getConfigurations(offset, limit, filter, select, countOnly, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Modify a specific configuration.
   * @param {string} uuid
   * @param {DeviceConfiguration} [deviceConfiguration] Information used to modify the new entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationsApi
   */
  public modifyConfiguration(uuid: string, deviceConfiguration?: DeviceConfiguration, options?: any) {
    return ConfigurationsApiFp(this.configuration)
      .modifyConfiguration(uuid, deviceConfiguration, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a specific entity.
     * @param {string} uuid
     * @param {Contact} [contact] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContact: async (uuid: string, contact?: Contact, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('createContact', 'uuid', uuid);
      const localVarPath = `/contact/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a specific contact.
     * @param {string} uuid
     * @param {boolean} force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContact: async (uuid: string, force: boolean, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('deleteContact', 'uuid', uuid);
      // verify required parameter 'force' is not null or undefined
      assertParamExists('deleteContact', 'force', force);
      const localVarPath = `/contact/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (force !== undefined) {
        localVarQueryParameter['force'] = force;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a specific contact.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContact: async (uuid: string, expandInUse?: boolean, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('getContact', 'uuid', uuid);
      const localVarPath = `/contact/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (expandInUse !== undefined) {
        localVarQueryParameter['expandInUse'] = expandInUse;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a list of contacts.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of contacts comma separated
     * @param {boolean} [countOnly] return the number of contacts
     * @param {boolean} [uuidOnly] return only the UUIDs of contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContacts: async (
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      uuidOnly?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/contact`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select;
      }

      if (countOnly !== undefined) {
        localVarQueryParameter['countOnly'] = countOnly;
      }

      if (uuidOnly !== undefined) {
        localVarQueryParameter['uuidOnly'] = uuidOnly;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Modify a specific contact.
     * @param {string} uuid
     * @param {Contact} [contact] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyContact: async (uuid: string, contact?: Contact, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modifyContact', 'uuid', uuid);
      const localVarPath = `/contact/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a specific entity.
     * @param {string} uuid
     * @param {Contact} [contact] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContact(
      uuid: string,
      contact?: Contact,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createContact(uuid, contact, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete a specific contact.
     * @param {string} uuid
     * @param {boolean} force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteContact(
      uuid: string,
      force: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContact(uuid, force, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a specific contact.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContact(
      uuid: string,
      expandInUse?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact | ExpandedUseEntryMapList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContact(uuid, expandInUse, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a list of contacts.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of contacts comma separated
     * @param {boolean} [countOnly] return the number of contacts
     * @param {boolean} [uuidOnly] return only the UUIDs of contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContacts(
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      uuidOnly?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactList | CountAnswer>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContacts(
        offset,
        limit,
        filter,
        select,
        countOnly,
        uuidOnly,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Modify a specific contact.
     * @param {string} uuid
     * @param {Contact} [contact] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modifyContact(
      uuid: string,
      contact?: Contact,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modifyContact(uuid, contact, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ContactsApiFp(configuration);
  return {
    /**
     *
     * @summary Create a specific entity.
     * @param {string} uuid
     * @param {Contact} [contact] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContact(uuid: string, contact?: Contact, options?: any): AxiosPromise<void> {
      return localVarFp.createContact(uuid, contact, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a specific contact.
     * @param {string} uuid
     * @param {boolean} force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContact(uuid: string, force: boolean, options?: any): AxiosPromise<object> {
      return localVarFp.deleteContact(uuid, force, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a specific contact.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContact(uuid: string, expandInUse?: boolean, options?: any): AxiosPromise<Contact | ExpandedUseEntryMapList> {
      return localVarFp.getContact(uuid, expandInUse, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a list of contacts.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of contacts comma separated
     * @param {boolean} [countOnly] return the number of contacts
     * @param {boolean} [uuidOnly] return only the UUIDs of contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContacts(
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      uuidOnly?: boolean,
      options?: any,
    ): AxiosPromise<ContactList | CountAnswer> {
      return localVarFp
        .getContacts(offset, limit, filter, select, countOnly, uuidOnly, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Modify a specific contact.
     * @param {string} uuid
     * @param {Contact} [contact] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyContact(uuid: string, contact?: Contact, options?: any): AxiosPromise<void> {
      return localVarFp.modifyContact(uuid, contact, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
  /**
   *
   * @summary Create a specific entity.
   * @param {string} uuid
   * @param {Contact} [contact] Information used to create the new entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public createContact(uuid: string, contact?: Contact, options?: any) {
    return ContactsApiFp(this.configuration)
      .createContact(uuid, contact, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a specific contact.
   * @param {string} uuid
   * @param {boolean} force
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public deleteContact(uuid: string, force: boolean, options?: any) {
    return ContactsApiFp(this.configuration)
      .deleteContact(uuid, force, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a specific contact.
   * @param {string} uuid
   * @param {boolean} [expandInUse]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public getContact(uuid: string, expandInUse?: boolean, options?: any) {
    return ContactsApiFp(this.configuration)
      .getContact(uuid, expandInUse, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a list of contacts.
   * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
   * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
   * @param {string} [filter] Filter the results
   * @param {string} [select] Supply a list of contacts comma separated
   * @param {boolean} [countOnly] return the number of contacts
   * @param {boolean} [uuidOnly] return only the UUIDs of contacts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public getContacts(
    offset?: number,
    limit?: number,
    filter?: string,
    select?: string,
    countOnly?: boolean,
    uuidOnly?: boolean,
    options?: any,
  ) {
    return ContactsApiFp(this.configuration)
      .getContacts(offset, limit, filter, select, countOnly, uuidOnly, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Modify a specific contact.
   * @param {string} uuid
   * @param {Contact} [contact] Information used to modify the new entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContactsApi
   */
  public modifyContact(uuid: string, contact?: Contact, options?: any) {
    return ContactsApiFp(this.configuration)
      .modifyContact(uuid, contact, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DashboardsApi - axios parameter creator
 * @export
 */
export const DashboardsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the last version of the dashboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeviceDashboard: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/dashboard`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DashboardsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get the last version of the dashboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDeviceDashboard(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceDashboard(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DashboardsApiFp(configuration);
  return {
    /**
     *
     * @summary Get the last version of the dashboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeviceDashboard(options?: any): AxiosPromise<void> {
      return localVarFp.getDeviceDashboard(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
  /**
   *
   * @summary Get the last version of the dashboard.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DashboardsApi
   */
  public getDeviceDashboard(options?: any) {
    return DashboardsApiFp(this.configuration)
      .getDeviceDashboard(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * EntitiesApi - axios parameter creator
 * @export
 */
export const EntitiesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a specific entity.
     * @param {string} uuid
     * @param {Entity} [entity] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity: async (uuid: string, entity?: Entity, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('createEntity', 'uuid', uuid);
      const localVarPath = `/entity/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(entity, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a specific entity.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEntity: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('deleteEntity', 'uuid', uuid);
      const localVarPath = `/entity/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a list of entities.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [countOnly] return the number of devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntities: async (
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/entity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select;
      }

      if (countOnly !== undefined) {
        localVarQueryParameter['countOnly'] = countOnly;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a specific entity.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntity: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('getEntity', 'uuid', uuid);
      const localVarPath = `/entity/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Modify a specific entity.
     * @param {string} uuid
     * @param {Entity} [entity] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyEntity: async (uuid: string, entity?: Entity, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modifyEntity', 'uuid', uuid);
      const localVarPath = `/entity/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(entity, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EntitiesApi - functional programming interface
 * @export
 */
export const EntitiesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EntitiesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a specific entity.
     * @param {string} uuid
     * @param {Entity} [entity] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEntity(
      uuid: string,
      entity?: Entity,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEntity(uuid, entity, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete a specific entity.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEntity(
      uuid: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntity(uuid, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a list of entities.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [countOnly] return the number of devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntities(
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityList | CountAnswer>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEntities(
        offset,
        limit,
        filter,
        select,
        countOnly,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a specific entity.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEntity(
      uuid: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEntity(uuid, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Modify a specific entity.
     * @param {string} uuid
     * @param {Entity} [entity] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modifyEntity(
      uuid: string,
      entity?: Entity,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modifyEntity(uuid, entity, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * EntitiesApi - factory interface
 * @export
 */
export const EntitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EntitiesApiFp(configuration);
  return {
    /**
     *
     * @summary Create a specific entity.
     * @param {string} uuid
     * @param {Entity} [entity] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEntity(uuid: string, entity?: Entity, options?: any): AxiosPromise<void> {
      return localVarFp.createEntity(uuid, entity, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a specific entity.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEntity(uuid: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteEntity(uuid, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a list of entities.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [countOnly] return the number of devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntities(
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options?: any,
    ): AxiosPromise<EntityList | CountAnswer> {
      return localVarFp
        .getEntities(offset, limit, filter, select, countOnly, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a specific entity.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEntity(uuid: string, options?: any): AxiosPromise<void> {
      return localVarFp.getEntity(uuid, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Modify a specific entity.
     * @param {string} uuid
     * @param {Entity} [entity] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyEntity(uuid: string, entity?: Entity, options?: any): AxiosPromise<void> {
      return localVarFp.modifyEntity(uuid, entity, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * EntitiesApi - object-oriented interface
 * @export
 * @class EntitiesApi
 * @extends {BaseAPI}
 */
export class EntitiesApi extends BaseAPI {
  /**
   *
   * @summary Create a specific entity.
   * @param {string} uuid
   * @param {Entity} [entity] Information used to create the new entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntitiesApi
   */
  public createEntity(uuid: string, entity?: Entity, options?: any) {
    return EntitiesApiFp(this.configuration)
      .createEntity(uuid, entity, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a specific entity.
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntitiesApi
   */
  public deleteEntity(uuid: string, options?: any) {
    return EntitiesApiFp(this.configuration)
      .deleteEntity(uuid, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a list of entities.
   * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
   * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
   * @param {string} [filter] Filter the results
   * @param {string} [select] Supply a list of devices comma separated
   * @param {boolean} [countOnly] return the number of devices
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntitiesApi
   */
  public getEntities(
    offset?: number,
    limit?: number,
    filter?: string,
    select?: string,
    countOnly?: boolean,
    options?: any,
  ) {
    return EntitiesApiFp(this.configuration)
      .getEntities(offset, limit, filter, select, countOnly, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a specific entity.
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntitiesApi
   */
  public getEntity(uuid: string, options?: any) {
    return EntitiesApiFp(this.configuration)
      .getEntity(uuid, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Modify a specific entity.
   * @param {string} uuid
   * @param {Entity} [entity] Information used to modify the new entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EntitiesApi
   */
  public modifyEntity(uuid: string, entity?: Entity, options?: any) {
    return EntitiesApiFp(this.configuration)
      .modifyEntity(uuid, entity, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * InventoryApi - axios parameter creator
 * @export
 */
export const InventoryApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a specific Inventory.
     * @param {string} serialNumber
     * @param {InventoryTag} [inventoryTag] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInventory: async (
      serialNumber: string,
      inventoryTag?: InventoryTag,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'serialNumber' is not null or undefined
      assertParamExists('createInventory', 'serialNumber', serialNumber);
      const localVarPath = `/inventory/{serialNumber}`.replace(
        `{${'serialNumber'}}`,
        encodeURIComponent(String(serialNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(inventoryTag, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a specific inventory.
     * @param {string} serialNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInventory: async (serialNumber: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'serialNumber' is not null or undefined
      assertParamExists('deleteInventory', 'serialNumber', serialNumber);
      const localVarPath = `/inventory/{serialNumber}`.replace(
        `{${'serialNumber'}}`,
        encodeURIComponent(String(serialNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a specific inventory tag.
     * @param {string} serialNumber
     * @param {boolean} [config]
     * @param {boolean} [explain]
     * @param {boolean} [firmwareOptions]
     * @param {boolean} [applyConfiguration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInventory: async (
      serialNumber: string,
      config?: boolean,
      explain?: boolean,
      firmwareOptions?: boolean,
      applyConfiguration?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'serialNumber' is not null or undefined
      assertParamExists('getInventory', 'serialNumber', serialNumber);
      const localVarPath = `/inventory/{serialNumber}`.replace(
        `{${'serialNumber'}}`,
        encodeURIComponent(String(serialNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (config !== undefined) {
        localVarQueryParameter['config'] = config;
      }

      if (explain !== undefined) {
        localVarQueryParameter['explain'] = explain;
      }

      if (firmwareOptions !== undefined) {
        localVarQueryParameter['firmwareOptions'] = firmwareOptions;
      }

      if (applyConfiguration !== undefined) {
        localVarQueryParameter['applyConfiguration'] = applyConfiguration;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a list of inventory.
     * @param {string} [entity]
     * @param {string} [venue]
     * @param {boolean} [unassigned]
     * @param {string} [deviceType]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [serialOnly] only serial numbers of full device details
     * @param {boolean} [countOnly] return the number of devices
     * @param {boolean} [withExtendedInfo] return extended information
     * @param {string} [orderBy] return extended information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInventoryTags: async (
      entity?: string,
      venue?: string,
      unassigned?: boolean,
      deviceType?: string,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      serialOnly?: boolean,
      countOnly?: boolean,
      withExtendedInfo?: boolean,
      orderBy?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/inventory`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (entity !== undefined) {
        localVarQueryParameter['entity'] = entity;
      }

      if (venue !== undefined) {
        localVarQueryParameter['venue'] = venue;
      }

      if (unassigned !== undefined) {
        localVarQueryParameter['unassigned'] = unassigned;
      }

      if (deviceType !== undefined) {
        localVarQueryParameter['deviceType'] = deviceType;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select;
      }

      if (serialOnly !== undefined) {
        localVarQueryParameter['serialOnly'] = serialOnly;
      }

      if (countOnly !== undefined) {
        localVarQueryParameter['countOnly'] = countOnly;
      }

      if (withExtendedInfo !== undefined) {
        localVarQueryParameter['withExtendedInfo'] = withExtendedInfo;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Modify a specific inventory.
     * @param {string} serialNumber
     * @param {boolean} [unassign]
     * @param {InventoryTag} [inventoryTag] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyInventory: async (
      serialNumber: string,
      unassign?: boolean,
      inventoryTag?: InventoryTag,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'serialNumber' is not null or undefined
      assertParamExists('modifyInventory', 'serialNumber', serialNumber);
      const localVarPath = `/inventory/{serialNumber}`.replace(
        `{${'serialNumber'}}`,
        encodeURIComponent(String(serialNumber)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (unassign !== undefined) {
        localVarQueryParameter['unassign'] = unassign;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(inventoryTag, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InventoryApi - functional programming interface
 * @export
 */
export const InventoryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = InventoryApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a specific Inventory.
     * @param {string} serialNumber
     * @param {InventoryTag} [inventoryTag] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createInventory(
      serialNumber: string,
      inventoryTag?: InventoryTag,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createInventory(serialNumber, inventoryTag, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete a specific inventory.
     * @param {string} serialNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteInventory(
      serialNumber: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInventory(serialNumber, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a specific inventory tag.
     * @param {string} serialNumber
     * @param {boolean} [config]
     * @param {boolean} [explain]
     * @param {boolean} [firmwareOptions]
     * @param {boolean} [applyConfiguration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInventory(
      serialNumber: string,
      config?: boolean,
      explain?: boolean,
      firmwareOptions?: boolean,
      applyConfiguration?: boolean,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InventoryTag | FirmwareOptions | InventoryConfigApplyResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInventory(
        serialNumber,
        config,
        explain,
        firmwareOptions,
        applyConfiguration,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a list of inventory.
     * @param {string} [entity]
     * @param {string} [venue]
     * @param {boolean} [unassigned]
     * @param {string} [deviceType]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [serialOnly] only serial numbers of full device details
     * @param {boolean} [countOnly] return the number of devices
     * @param {boolean} [withExtendedInfo] return extended information
     * @param {string} [orderBy] return extended information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInventoryTags(
      entity?: string,
      venue?: string,
      unassigned?: boolean,
      deviceType?: string,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      serialOnly?: boolean,
      countOnly?: boolean,
      withExtendedInfo?: boolean,
      orderBy?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SerialNumberList | InventoryTagList | CountAnswer>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInventoryTags(
        entity,
        venue,
        unassigned,
        deviceType,
        offset,
        limit,
        filter,
        select,
        serialOnly,
        countOnly,
        withExtendedInfo,
        orderBy,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Modify a specific inventory.
     * @param {string} serialNumber
     * @param {boolean} [unassign]
     * @param {InventoryTag} [inventoryTag] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modifyInventory(
      serialNumber: string,
      unassign?: boolean,
      inventoryTag?: InventoryTag,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modifyInventory(
        serialNumber,
        unassign,
        inventoryTag,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * InventoryApi - factory interface
 * @export
 */
export const InventoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = InventoryApiFp(configuration);
  return {
    /**
     *
     * @summary Create a specific Inventory.
     * @param {string} serialNumber
     * @param {InventoryTag} [inventoryTag] Information used to create the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInventory(serialNumber: string, inventoryTag?: InventoryTag, options?: any): AxiosPromise<void> {
      return localVarFp.createInventory(serialNumber, inventoryTag, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a specific inventory.
     * @param {string} serialNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInventory(serialNumber: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteInventory(serialNumber, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a specific inventory tag.
     * @param {string} serialNumber
     * @param {boolean} [config]
     * @param {boolean} [explain]
     * @param {boolean} [firmwareOptions]
     * @param {boolean} [applyConfiguration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInventory(
      serialNumber: string,
      config?: boolean,
      explain?: boolean,
      firmwareOptions?: boolean,
      applyConfiguration?: boolean,
      options?: any,
    ): AxiosPromise<InventoryTag | FirmwareOptions | InventoryConfigApplyResult> {
      return localVarFp
        .getInventory(serialNumber, config, explain, firmwareOptions, applyConfiguration, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a list of inventory.
     * @param {string} [entity]
     * @param {string} [venue]
     * @param {boolean} [unassigned]
     * @param {string} [deviceType]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [serialOnly] only serial numbers of full device details
     * @param {boolean} [countOnly] return the number of devices
     * @param {boolean} [withExtendedInfo] return extended information
     * @param {string} [orderBy] return extended information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInventoryTags(
      entity?: string,
      venue?: string,
      unassigned?: boolean,
      deviceType?: string,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      serialOnly?: boolean,
      countOnly?: boolean,
      withExtendedInfo?: boolean,
      orderBy?: string,
      options?: any,
    ): AxiosPromise<SerialNumberList | InventoryTagList | CountAnswer> {
      return localVarFp
        .getInventoryTags(
          entity,
          venue,
          unassigned,
          deviceType,
          offset,
          limit,
          filter,
          select,
          serialOnly,
          countOnly,
          withExtendedInfo,
          orderBy,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Modify a specific inventory.
     * @param {string} serialNumber
     * @param {boolean} [unassign]
     * @param {InventoryTag} [inventoryTag] Information used to modify the new entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyInventory(
      serialNumber: string,
      unassign?: boolean,
      inventoryTag?: InventoryTag,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .modifyInventory(serialNumber, unassign, inventoryTag, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
export class InventoryApi extends BaseAPI {
  /**
   *
   * @summary Create a specific Inventory.
   * @param {string} serialNumber
   * @param {InventoryTag} [inventoryTag] Information used to create the new entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public createInventory(serialNumber: string, inventoryTag?: InventoryTag, options?: any) {
    return InventoryApiFp(this.configuration)
      .createInventory(serialNumber, inventoryTag, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a specific inventory.
   * @param {string} serialNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public deleteInventory(serialNumber: string, options?: any) {
    return InventoryApiFp(this.configuration)
      .deleteInventory(serialNumber, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a specific inventory tag.
   * @param {string} serialNumber
   * @param {boolean} [config]
   * @param {boolean} [explain]
   * @param {boolean} [firmwareOptions]
   * @param {boolean} [applyConfiguration]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public getInventory(
    serialNumber: string,
    config?: boolean,
    explain?: boolean,
    firmwareOptions?: boolean,
    applyConfiguration?: boolean,
    options?: any,
  ) {
    return InventoryApiFp(this.configuration)
      .getInventory(serialNumber, config, explain, firmwareOptions, applyConfiguration, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a list of inventory.
   * @param {string} [entity]
   * @param {string} [venue]
   * @param {boolean} [unassigned]
   * @param {string} [deviceType]
   * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
   * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
   * @param {string} [filter] Filter the results
   * @param {string} [select] Supply a list of devices comma separated
   * @param {boolean} [serialOnly] only serial numbers of full device details
   * @param {boolean} [countOnly] return the number of devices
   * @param {boolean} [withExtendedInfo] return extended information
   * @param {string} [orderBy] return extended information
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public getInventoryTags(
    entity?: string,
    venue?: string,
    unassigned?: boolean,
    deviceType?: string,
    offset?: number,
    limit?: number,
    filter?: string,
    select?: string,
    serialOnly?: boolean,
    countOnly?: boolean,
    withExtendedInfo?: boolean,
    orderBy?: string,
    options?: any,
  ) {
    return InventoryApiFp(this.configuration)
      .getInventoryTags(
        entity,
        venue,
        unassigned,
        deviceType,
        offset,
        limit,
        filter,
        select,
        serialOnly,
        countOnly,
        withExtendedInfo,
        orderBy,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Modify a specific inventory.
   * @param {string} serialNumber
   * @param {boolean} [unassign]
   * @param {InventoryTag} [inventoryTag] Information used to modify the new entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public modifyInventory(serialNumber: string, unassign?: boolean, inventoryTag?: InventoryTag, options?: any) {
    return InventoryApiFp(this.configuration)
      .modifyInventory(serialNumber, unassign, inventoryTag, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * LocationsApi - axios parameter creator
 * @export
 */
export const LocationsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a specific location.
     * @param {string} uuid
     * @param {Location} [location] Information used to create the new location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLocation: async (uuid: string, location?: Location, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('createLocation', 'uuid', uuid);
      const localVarPath = `/location/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(location, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a specific location.
     * @param {string} uuid
     * @param {boolean} force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLocation: async (uuid: string, force: boolean, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('deleteLocation', 'uuid', uuid);
      // verify required parameter 'force' is not null or undefined
      assertParamExists('deleteLocation', 'force', force);
      const localVarPath = `/location/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (force !== undefined) {
        localVarQueryParameter['force'] = force;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a specific location.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocation: async (uuid: string, expandInUse?: boolean, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('getLocation', 'uuid', uuid);
      const localVarPath = `/location/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (expandInUse !== undefined) {
        localVarQueryParameter['expandInUse'] = expandInUse;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a list of locations.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of Locations comma separated
     * @param {boolean} [countOnly] return the number of Locations
     * @param {boolean} [uuidOnly] return only the UUIDs of Locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocations: async (
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      uuidOnly?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/location`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select;
      }

      if (countOnly !== undefined) {
        localVarQueryParameter['countOnly'] = countOnly;
      }

      if (uuidOnly !== undefined) {
        localVarQueryParameter['uuidOnly'] = uuidOnly;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Modify a specific location.
     * @param {string} uuid
     * @param {Location} [location] Information used to modify the new location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyLocation: async (uuid: string, location?: Location, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modifyLocation', 'uuid', uuid);
      const localVarPath = `/location/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(location, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LocationsApi - functional programming interface
 * @export
 */
export const LocationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LocationsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a specific location.
     * @param {string} uuid
     * @param {Location} [location] Information used to create the new location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLocation(
      uuid: string,
      location?: Location,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLocation(uuid, location, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete a specific location.
     * @param {string} uuid
     * @param {boolean} force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLocation(
      uuid: string,
      force: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLocation(uuid, force, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a specific location.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLocation(
      uuid: string,
      expandInUse?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Location | ExpandedUseEntryMapList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLocation(uuid, expandInUse, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a list of locations.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of Locations comma separated
     * @param {boolean} [countOnly] return the number of Locations
     * @param {boolean} [uuidOnly] return only the UUIDs of Locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLocations(
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      uuidOnly?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationList | CountAnswer>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLocations(
        offset,
        limit,
        filter,
        select,
        countOnly,
        uuidOnly,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Modify a specific location.
     * @param {string} uuid
     * @param {Location} [location] Information used to modify the new location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modifyLocation(
      uuid: string,
      location?: Location,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modifyLocation(uuid, location, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LocationsApi - factory interface
 * @export
 */
export const LocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = LocationsApiFp(configuration);
  return {
    /**
     *
     * @summary Create a specific location.
     * @param {string} uuid
     * @param {Location} [location] Information used to create the new location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLocation(uuid: string, location?: Location, options?: any): AxiosPromise<void> {
      return localVarFp.createLocation(uuid, location, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a specific location.
     * @param {string} uuid
     * @param {boolean} force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLocation(uuid: string, force: boolean, options?: any): AxiosPromise<object> {
      return localVarFp.deleteLocation(uuid, force, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a specific location.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocation(uuid: string, expandInUse?: boolean, options?: any): AxiosPromise<Location | ExpandedUseEntryMapList> {
      return localVarFp.getLocation(uuid, expandInUse, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a list of locations.
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of Locations comma separated
     * @param {boolean} [countOnly] return the number of Locations
     * @param {boolean} [uuidOnly] return only the UUIDs of Locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocations(
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      uuidOnly?: boolean,
      options?: any,
    ): AxiosPromise<LocationList | CountAnswer> {
      return localVarFp
        .getLocations(offset, limit, filter, select, countOnly, uuidOnly, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Modify a specific location.
     * @param {string} uuid
     * @param {Location} [location] Information used to modify the new location
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyLocation(uuid: string, location?: Location, options?: any): AxiosPromise<void> {
      return localVarFp.modifyLocation(uuid, location, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * LocationsApi - object-oriented interface
 * @export
 * @class LocationsApi
 * @extends {BaseAPI}
 */
export class LocationsApi extends BaseAPI {
  /**
   *
   * @summary Create a specific location.
   * @param {string} uuid
   * @param {Location} [location] Information used to create the new location
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationsApi
   */
  public createLocation(uuid: string, location?: Location, options?: any) {
    return LocationsApiFp(this.configuration)
      .createLocation(uuid, location, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a specific location.
   * @param {string} uuid
   * @param {boolean} force
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationsApi
   */
  public deleteLocation(uuid: string, force: boolean, options?: any) {
    return LocationsApiFp(this.configuration)
      .deleteLocation(uuid, force, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a specific location.
   * @param {string} uuid
   * @param {boolean} [expandInUse]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationsApi
   */
  public getLocation(uuid: string, expandInUse?: boolean, options?: any) {
    return LocationsApiFp(this.configuration)
      .getLocation(uuid, expandInUse, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a list of locations.
   * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
   * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
   * @param {string} [filter] Filter the results
   * @param {string} [select] Supply a list of Locations comma separated
   * @param {boolean} [countOnly] return the number of Locations
   * @param {boolean} [uuidOnly] return only the UUIDs of Locations
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationsApi
   */
  public getLocations(
    offset?: number,
    limit?: number,
    filter?: string,
    select?: string,
    countOnly?: boolean,
    uuidOnly?: boolean,
    options?: any,
  ) {
    return LocationsApiFp(this.configuration)
      .getLocations(offset, limit, filter, select, countOnly, uuidOnly, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Modify a specific location.
   * @param {string} uuid
   * @param {Location} [location] Information used to modify the new location
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LocationsApi
   */
  public modifyLocation(uuid: string, location?: Location, options?: any) {
    return LocationsApiFp(this.configuration)
      .modifyLocation(uuid, location, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ManagementPoliciesApi - axios parameter creator
 * @export
 */
export const ManagementPoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a specific policy.
     * @param {string} uuid
     * @param {ManagementPolicy} [managementPolicy] Information used to create the new policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createManagementPolicy: async (
      uuid: string,
      managementPolicy?: ManagementPolicy,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('createManagementPolicy', 'uuid', uuid);
      const localVarPath = `/managementPolicy/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(managementPolicy, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a specific policy.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteManagementPolicy: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('deleteManagementPolicy', 'uuid', uuid);
      const localVarPath = `/managementPolicy/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a specific policy.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagementPolicy: async (uuid: string, expandInUse?: boolean, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('getManagementPolicy', 'uuid', uuid);
      const localVarPath = `/managementPolicy/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (expandInUse !== undefined) {
        localVarQueryParameter['expandInUse'] = expandInUse;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a list of policies.
     * @param {string} [entity]
     * @param {string} [venue]
     * @param {boolean} [unassigned]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of policies comma separated
     * @param {boolean} [countOnly] return the number of policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicies: async (
      entity?: string,
      venue?: string,
      unassigned?: boolean,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/managementPolicy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (entity !== undefined) {
        localVarQueryParameter['entity'] = entity;
      }

      if (venue !== undefined) {
        localVarQueryParameter['venue'] = venue;
      }

      if (unassigned !== undefined) {
        localVarQueryParameter['unassigned'] = unassigned;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select;
      }

      if (countOnly !== undefined) {
        localVarQueryParameter['countOnly'] = countOnly;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Modify a specific policy.
     * @param {string} uuid
     * @param {ManagementPolicy} [managementPolicy] Information used to modify the new policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyManagementPolicy: async (
      uuid: string,
      managementPolicy?: ManagementPolicy,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modifyManagementPolicy', 'uuid', uuid);
      const localVarPath = `/managementPolicy/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(managementPolicy, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ManagementPoliciesApi - functional programming interface
 * @export
 */
export const ManagementPoliciesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ManagementPoliciesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a specific policy.
     * @param {string} uuid
     * @param {ManagementPolicy} [managementPolicy] Information used to create the new policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createManagementPolicy(
      uuid: string,
      managementPolicy?: ManagementPolicy,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createManagementPolicy(uuid, managementPolicy, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete a specific policy.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteManagementPolicy(
      uuid: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManagementPolicy(uuid, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a specific policy.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getManagementPolicy(
      uuid: string,
      expandInUse?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagementPolicy | ExpandedUseEntryMapList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getManagementPolicy(uuid, expandInUse, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get a list of policies.
     * @param {string} [entity]
     * @param {string} [venue]
     * @param {boolean} [unassigned]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of policies comma separated
     * @param {boolean} [countOnly] return the number of policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPolicies(
      entity?: string,
      venue?: string,
      unassigned?: boolean,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagementPolicyList | CountAnswer>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicies(
        entity,
        venue,
        unassigned,
        offset,
        limit,
        filter,
        select,
        countOnly,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Modify a specific policy.
     * @param {string} uuid
     * @param {ManagementPolicy} [managementPolicy] Information used to modify the new policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modifyManagementPolicy(
      uuid: string,
      managementPolicy?: ManagementPolicy,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modifyManagementPolicy(uuid, managementPolicy, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ManagementPoliciesApi - factory interface
 * @export
 */
export const ManagementPoliciesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ManagementPoliciesApiFp(configuration);
  return {
    /**
     *
     * @summary Create a specific policy.
     * @param {string} uuid
     * @param {ManagementPolicy} [managementPolicy] Information used to create the new policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createManagementPolicy(uuid: string, managementPolicy?: ManagementPolicy, options?: any): AxiosPromise<void> {
      return localVarFp
        .createManagementPolicy(uuid, managementPolicy, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a specific policy.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteManagementPolicy(uuid: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteManagementPolicy(uuid, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a specific policy.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagementPolicy(
      uuid: string,
      expandInUse?: boolean,
      options?: any,
    ): AxiosPromise<ManagementPolicy | ExpandedUseEntryMapList> {
      return localVarFp.getManagementPolicy(uuid, expandInUse, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get a list of policies.
     * @param {string} [entity]
     * @param {string} [venue]
     * @param {boolean} [unassigned]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of policies comma separated
     * @param {boolean} [countOnly] return the number of policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicies(
      entity?: string,
      venue?: string,
      unassigned?: boolean,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options?: any,
    ): AxiosPromise<ManagementPolicyList | CountAnswer> {
      return localVarFp
        .getPolicies(entity, venue, unassigned, offset, limit, filter, select, countOnly, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Modify a specific policy.
     * @param {string} uuid
     * @param {ManagementPolicy} [managementPolicy] Information used to modify the new policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyManagementPolicy(uuid: string, managementPolicy?: ManagementPolicy, options?: any): AxiosPromise<void> {
      return localVarFp
        .modifyManagementPolicy(uuid, managementPolicy, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * ManagementPoliciesApi - object-oriented interface
 * @export
 * @class ManagementPoliciesApi
 * @extends {BaseAPI}
 */
export class ManagementPoliciesApi extends BaseAPI {
  /**
   *
   * @summary Create a specific policy.
   * @param {string} uuid
   * @param {ManagementPolicy} [managementPolicy] Information used to create the new policy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagementPoliciesApi
   */
  public createManagementPolicy(uuid: string, managementPolicy?: ManagementPolicy, options?: any) {
    return ManagementPoliciesApiFp(this.configuration)
      .createManagementPolicy(uuid, managementPolicy, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a specific policy.
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagementPoliciesApi
   */
  public deleteManagementPolicy(uuid: string, options?: any) {
    return ManagementPoliciesApiFp(this.configuration)
      .deleteManagementPolicy(uuid, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a specific policy.
   * @param {string} uuid
   * @param {boolean} [expandInUse]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagementPoliciesApi
   */
  public getManagementPolicy(uuid: string, expandInUse?: boolean, options?: any) {
    return ManagementPoliciesApiFp(this.configuration)
      .getManagementPolicy(uuid, expandInUse, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a list of policies.
   * @param {string} [entity]
   * @param {string} [venue]
   * @param {boolean} [unassigned]
   * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
   * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
   * @param {string} [filter] Filter the results
   * @param {string} [select] Supply a list of policies comma separated
   * @param {boolean} [countOnly] return the number of policies
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagementPoliciesApi
   */
  public getPolicies(
    entity?: string,
    venue?: string,
    unassigned?: boolean,
    offset?: number,
    limit?: number,
    filter?: string,
    select?: string,
    countOnly?: boolean,
    options?: any,
  ) {
    return ManagementPoliciesApiFp(this.configuration)
      .getPolicies(entity, venue, unassigned, offset, limit, filter, select, countOnly, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Modify a specific policy.
   * @param {string} uuid
   * @param {ManagementPolicy} [managementPolicy] Information used to modify the new policy.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagementPoliciesApi
   */
  public modifyManagementPolicy(uuid: string, managementPolicy?: ManagementPolicy, options?: any) {
    return ManagementPoliciesApiFp(this.configuration)
      .modifyManagementPolicy(uuid, managementPolicy, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ManagementRolesApi - axios parameter creator
 * @export
 */
export const ManagementRolesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a specific management role.
     * @param {string} uuid
     * @param {ManagementRole} [managementRole] Information used to create management role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createManagementRole: async (
      uuid: string,
      managementRole?: ManagementRole,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('createManagementRole', 'uuid', uuid);
      const localVarPath = `/managementRole/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(managementRole, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a specific management role.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteManagementRole: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('deleteManagementRole', 'uuid', uuid);
      const localVarPath = `/managementRole/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a specific management role.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagementRole: async (uuid: string, expandInUse?: boolean, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('getManagementRole', 'uuid', uuid);
      const localVarPath = `/managementRole/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (expandInUse !== undefined) {
        localVarQueryParameter['expandInUse'] = expandInUse;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a list of management roles.
     * @param {string} [entity]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [countOnly] return the number of roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagementRoles: async (
      entity?: string,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/managementRole`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (entity !== undefined) {
        localVarQueryParameter['entity'] = entity;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select;
      }

      if (countOnly !== undefined) {
        localVarQueryParameter['countOnly'] = countOnly;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Modify a specific management role.
     * @param {string} uuid
     * @param {ManagementRole} [managementRole] Information used to modify management role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyManagementRole: async (
      uuid: string,
      managementRole?: ManagementRole,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modifyManagementRole', 'uuid', uuid);
      const localVarPath = `/managementRole/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(managementRole, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ManagementRolesApi - functional programming interface
 * @export
 */
export const ManagementRolesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ManagementRolesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a specific management role.
     * @param {string} uuid
     * @param {ManagementRole} [managementRole] Information used to create management role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createManagementRole(
      uuid: string,
      managementRole?: ManagementRole,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createManagementRole(uuid, managementRole, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete a specific management role.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteManagementRole(
      uuid: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManagementRole(uuid, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a specific management role.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getManagementRole(
      uuid: string,
      expandInUse?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagementRole | ExpandedUseEntryMapList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getManagementRole(uuid, expandInUse, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a list of management roles.
     * @param {string} [entity]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [countOnly] return the number of roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getManagementRoles(
      entity?: string,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagementRoleList | CountAnswer>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getManagementRoles(
        entity,
        offset,
        limit,
        filter,
        select,
        countOnly,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Modify a specific management role.
     * @param {string} uuid
     * @param {ManagementRole} [managementRole] Information used to modify management role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modifyManagementRole(
      uuid: string,
      managementRole?: ManagementRole,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modifyManagementRole(uuid, managementRole, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ManagementRolesApi - factory interface
 * @export
 */
export const ManagementRolesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ManagementRolesApiFp(configuration);
  return {
    /**
     *
     * @summary Create a specific management role.
     * @param {string} uuid
     * @param {ManagementRole} [managementRole] Information used to create management role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createManagementRole(uuid: string, managementRole?: ManagementRole, options?: any): AxiosPromise<void> {
      return localVarFp.createManagementRole(uuid, managementRole, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a specific management role.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteManagementRole(uuid: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteManagementRole(uuid, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a specific management role.
     * @param {string} uuid
     * @param {boolean} [expandInUse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagementRole(
      uuid: string,
      expandInUse?: boolean,
      options?: any,
    ): AxiosPromise<ManagementRole | ExpandedUseEntryMapList> {
      return localVarFp.getManagementRole(uuid, expandInUse, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a list of management roles.
     * @param {string} [entity]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of devices comma separated
     * @param {boolean} [countOnly] return the number of roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManagementRoles(
      entity?: string,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      countOnly?: boolean,
      options?: any,
    ): AxiosPromise<ManagementRoleList | CountAnswer> {
      return localVarFp
        .getManagementRoles(entity, offset, limit, filter, select, countOnly, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Modify a specific management role.
     * @param {string} uuid
     * @param {ManagementRole} [managementRole] Information used to modify management role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyManagementRole(uuid: string, managementRole?: ManagementRole, options?: any): AxiosPromise<void> {
      return localVarFp.modifyManagementRole(uuid, managementRole, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * ManagementRolesApi - object-oriented interface
 * @export
 * @class ManagementRolesApi
 * @extends {BaseAPI}
 */
export class ManagementRolesApi extends BaseAPI {
  /**
   *
   * @summary Create a specific management role.
   * @param {string} uuid
   * @param {ManagementRole} [managementRole] Information used to create management role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagementRolesApi
   */
  public createManagementRole(uuid: string, managementRole?: ManagementRole, options?: any) {
    return ManagementRolesApiFp(this.configuration)
      .createManagementRole(uuid, managementRole, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a specific management role.
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagementRolesApi
   */
  public deleteManagementRole(uuid: string, options?: any) {
    return ManagementRolesApiFp(this.configuration)
      .deleteManagementRole(uuid, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a specific management role.
   * @param {string} uuid
   * @param {boolean} [expandInUse]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagementRolesApi
   */
  public getManagementRole(uuid: string, expandInUse?: boolean, options?: any) {
    return ManagementRolesApiFp(this.configuration)
      .getManagementRole(uuid, expandInUse, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a list of management roles.
   * @param {string} [entity]
   * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
   * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
   * @param {string} [filter] Filter the results
   * @param {string} [select] Supply a list of devices comma separated
   * @param {boolean} [countOnly] return the number of roles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagementRolesApi
   */
  public getManagementRoles(
    entity?: string,
    offset?: number,
    limit?: number,
    filter?: string,
    select?: string,
    countOnly?: boolean,
    options?: any,
  ) {
    return ManagementRolesApiFp(this.configuration)
      .getManagementRoles(entity, offset, limit, filter, select, countOnly, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Modify a specific management role.
   * @param {string} uuid
   * @param {ManagementRole} [managementRole] Information used to modify management role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManagementRolesApi
   */
  public modifyManagementRole(uuid: string, managementRole?: ManagementRole, options?: any) {
    return ManagementRolesApiFp(this.configuration)
      .modifyManagementRole(uuid, managementRole, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SystemCommandsApi - axios parameter creator
 * @export
 */
export const SystemCommandsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Retrieve different values from the running service.
     * @param {'info'} command Get a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemCommand: async (command: 'info', options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'command' is not null or undefined
      assertParamExists('getSystemCommand', 'command', command);
      const localVarPath = `/system`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (command !== undefined) {
        localVarQueryParameter['command'] = command;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Perform some system wide commands.
     * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemCommand: async (
      systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?:
        | SystemCommandSetLogLevel
        | SystemCommandReload
        | SystemCommandGetLogLevels
        | SystemCommandGetLogLevelNames
        | SystemCommandGetSubsystemNames,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/system`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SystemCommandsApi - functional programming interface
 * @export
 */
export const SystemCommandsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SystemCommandsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Retrieve different values from the running service.
     * @param {'info'} command Get a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystemCommand(
      command: 'info',
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfoResults>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemCommand(command, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Perform some system wide commands.
     * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async systemCommand(
      systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?:
        | SystemCommandSetLogLevel
        | SystemCommandReload
        | SystemCommandGetLogLevels
        | SystemCommandGetLogLevelNames
        | SystemCommandGetSubsystemNames,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SystemGetLogLevelsResult | SystemCommandGetLogLevelNamesResult | SystemGetSubSystemNamesResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.systemCommand(
        systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SystemCommandsApi - factory interface
 * @export
 */
export const SystemCommandsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SystemCommandsApiFp(configuration);
  return {
    /**
     *
     * @summary Retrieve different values from the running service.
     * @param {'info'} command Get a value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemCommand(command: 'info', options?: any): AxiosPromise<SystemInfoResults> {
      return localVarFp.getSystemCommand(command, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Perform some system wide commands.
     * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    systemCommand(
      systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?:
        | SystemCommandSetLogLevel
        | SystemCommandReload
        | SystemCommandGetLogLevels
        | SystemCommandGetLogLevelNames
        | SystemCommandGetSubsystemNames,
      options?: any,
    ): AxiosPromise<SystemGetLogLevelsResult | SystemCommandGetLogLevelNamesResult | SystemGetSubSystemNamesResult> {
      return localVarFp
        .systemCommand(
          systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames,
          options,
        )
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * SystemCommandsApi - object-oriented interface
 * @export
 * @class SystemCommandsApi
 * @extends {BaseAPI}
 */
export class SystemCommandsApi extends BaseAPI {
  /**
   *
   * @summary Retrieve different values from the running service.
   * @param {'info'} command Get a value
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemCommandsApi
   */
  public getSystemCommand(command: 'info', options?: any) {
    return SystemCommandsApiFp(this.configuration)
      .getSystemCommand(command, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Perform some system wide commands.
   * @param {SystemCommandSetLogLevel | SystemCommandReload | SystemCommandGetLogLevels | SystemCommandGetLogLevelNames | SystemCommandGetSubsystemNames} [systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames] Command details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemCommandsApi
   */
  public systemCommand(
    systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames?:
      | SystemCommandSetLogLevel
      | SystemCommandReload
      | SystemCommandGetLogLevels
      | SystemCommandGetLogLevelNames
      | SystemCommandGetSubsystemNames,
    options?: any,
  ) {
    return SystemCommandsApiFp(this.configuration)
      .systemCommand(
        systemCommandSetLogLevelSystemCommandReloadSystemCommandGetLogLevelsSystemCommandGetLogLevelNamesSystemCommandGetSubsystemNames,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * VenuesApi - axios parameter creator
 * @export
 */
export const VenuesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a specific venue.
     * @param {string} uuid
     * @param {Venue} [venue] Information used to create the new venue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVenue: async (uuid: string, venue?: Venue, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('createVenue', 'uuid', uuid);
      const localVarPath = `/venue/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(venue, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a specific venue.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVenue: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('deleteVenue', 'uuid', uuid);
      const localVarPath = `/venue/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a specific venue.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVenue: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('getVenue', 'uuid', uuid);
      const localVarPath = `/venue/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve a list of venues.
     * @param {string} [entity]
     * @param {string} [venue]
     * @param {boolean} [unassigned]
     * @param {string} [deviceType]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of Venues comma separated
     * @param {boolean} [serialOnly] only serial numbers of full device details
     * @param {boolean} [countOnly] return the number of devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVenues: async (
      entity?: string,
      venue?: string,
      unassigned?: boolean,
      deviceType?: string,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      serialOnly?: boolean,
      countOnly?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/venue`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (entity !== undefined) {
        localVarQueryParameter['entity'] = entity;
      }

      if (venue !== undefined) {
        localVarQueryParameter['venue'] = venue;
      }

      if (unassigned !== undefined) {
        localVarQueryParameter['unassigned'] = unassigned;
      }

      if (deviceType !== undefined) {
        localVarQueryParameter['deviceType'] = deviceType;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (select !== undefined) {
        localVarQueryParameter['select'] = select;
      }

      if (serialOnly !== undefined) {
        localVarQueryParameter['serialOnly'] = serialOnly;
      }

      if (countOnly !== undefined) {
        localVarQueryParameter['countOnly'] = countOnly;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Modify a specific venue.
     * @param {string} uuid
     * @param {Venue} [venue] Information used to modify the new venue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyVenue: async (uuid: string, venue?: Venue, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('modifyVenue', 'uuid', uuid);
      const localVarPath = `/venue/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(venue, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VenuesApi - functional programming interface
 * @export
 */
export const VenuesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VenuesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a specific venue.
     * @param {string} uuid
     * @param {Venue} [venue] Information used to create the new venue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createVenue(
      uuid: string,
      venue?: Venue,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createVenue(uuid, venue, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete a specific venue.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteVenue(
      uuid: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVenue(uuid, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a specific venue.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenue(
      uuid: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVenue(uuid, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve a list of venues.
     * @param {string} [entity]
     * @param {string} [venue]
     * @param {boolean} [unassigned]
     * @param {string} [deviceType]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of Venues comma separated
     * @param {boolean} [serialOnly] only serial numbers of full device details
     * @param {boolean} [countOnly] return the number of devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenues(
      entity?: string,
      venue?: string,
      unassigned?: boolean,
      deviceType?: string,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      serialOnly?: boolean,
      countOnly?: boolean,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VenueList | CountAnswer>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVenues(
        entity,
        venue,
        unassigned,
        deviceType,
        offset,
        limit,
        filter,
        select,
        serialOnly,
        countOnly,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Modify a specific venue.
     * @param {string} uuid
     * @param {Venue} [venue] Information used to modify the new venue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async modifyVenue(
      uuid: string,
      venue?: Venue,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.modifyVenue(uuid, venue, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * VenuesApi - factory interface
 * @export
 */
export const VenuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = VenuesApiFp(configuration);
  return {
    /**
     *
     * @summary Create a specific venue.
     * @param {string} uuid
     * @param {Venue} [venue] Information used to create the new venue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVenue(uuid: string, venue?: Venue, options?: any): AxiosPromise<void> {
      return localVarFp.createVenue(uuid, venue, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a specific venue.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVenue(uuid: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteVenue(uuid, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a specific venue.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVenue(uuid: string, options?: any): AxiosPromise<void> {
      return localVarFp.getVenue(uuid, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve a list of venues.
     * @param {string} [entity]
     * @param {string} [venue]
     * @param {boolean} [unassigned]
     * @param {string} [deviceType]
     * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
     * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
     * @param {string} [filter] Filter the results
     * @param {string} [select] Supply a list of Venues comma separated
     * @param {boolean} [serialOnly] only serial numbers of full device details
     * @param {boolean} [countOnly] return the number of devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVenues(
      entity?: string,
      venue?: string,
      unassigned?: boolean,
      deviceType?: string,
      offset?: number,
      limit?: number,
      filter?: string,
      select?: string,
      serialOnly?: boolean,
      countOnly?: boolean,
      options?: any,
    ): AxiosPromise<VenueList | CountAnswer> {
      return localVarFp
        .getVenues(entity, venue, unassigned, deviceType, offset, limit, filter, select, serialOnly, countOnly, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Modify a specific venue.
     * @param {string} uuid
     * @param {Venue} [venue] Information used to modify the new venue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    modifyVenue(uuid: string, venue?: Venue, options?: any): AxiosPromise<void> {
      return localVarFp.modifyVenue(uuid, venue, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * VenuesApi - object-oriented interface
 * @export
 * @class VenuesApi
 * @extends {BaseAPI}
 */
export class VenuesApi extends BaseAPI {
  /**
   *
   * @summary Create a specific venue.
   * @param {string} uuid
   * @param {Venue} [venue] Information used to create the new venue
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VenuesApi
   */
  public createVenue(uuid: string, venue?: Venue, options?: any) {
    return VenuesApiFp(this.configuration)
      .createVenue(uuid, venue, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a specific venue.
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VenuesApi
   */
  public deleteVenue(uuid: string, options?: any) {
    return VenuesApiFp(this.configuration)
      .deleteVenue(uuid, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a specific venue.
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VenuesApi
   */
  public getVenue(uuid: string, options?: any) {
    return VenuesApiFp(this.configuration)
      .getVenue(uuid, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve a list of venues.
   * @param {string} [entity]
   * @param {string} [venue]
   * @param {boolean} [unassigned]
   * @param {string} [deviceType]
   * @param {number} [offset] Pagination start (starts at 1. If not specified, 1 is assumed)
   * @param {number} [limit] Maximum number of entries to return (if absent, no limit is assumed)
   * @param {string} [filter] Filter the results
   * @param {string} [select] Supply a list of Venues comma separated
   * @param {boolean} [serialOnly] only serial numbers of full device details
   * @param {boolean} [countOnly] return the number of devices
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VenuesApi
   */
  public getVenues(
    entity?: string,
    venue?: string,
    unassigned?: boolean,
    deviceType?: string,
    offset?: number,
    limit?: number,
    filter?: string,
    select?: string,
    serialOnly?: boolean,
    countOnly?: boolean,
    options?: any,
  ) {
    return VenuesApiFp(this.configuration)
      .getVenues(entity, venue, unassigned, deviceType, offset, limit, filter, select, serialOnly, countOnly, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Modify a specific venue.
   * @param {string} uuid
   * @param {Venue} [venue] Information used to modify the new venue
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VenuesApi
   */
  public modifyVenue(uuid: string, venue?: Venue, options?: any) {
    return VenuesApiFp(this.configuration)
      .modifyVenue(uuid, venue, options)
      .then(request => request(this.axios, this.basePath));
  }
}
